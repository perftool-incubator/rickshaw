#!/usr/bin/env bash
# -*- mode: sh; indent-tabs-mode: nil; sh-basic-offset: 4 -*-
# vim: autoindent tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=bash
#set -u

# Shared init and functions for endpoints

echo "#params: $@"
host="" # the host the endpoint works with
controller_ipaddr=""
rb_exit_success=0
rb_exit_timeout=3
rb_exit_abort=4
rb_exit_input=2
max_rb_attempts=""
cs_rb_opts=""
do_validate="0"
num_clients=0
num_servers=0
num_collectors=0
disable_tools=0
abort=0
userenv=""
user=""
max_sample_failures=""
total_cpu_partitions=0
export ssh_opts="-q -o StrictHostKeyChecking=no -o PasswordAuthentication=no"
declare -A clients
declare -A servers
declare -A collectors # For a remotehost that has no client or server, but runs tools
declare -A id_to_bench
declare -A bench_to_image
declare -A cpuPartitioning
declare -A osruntime
cpuPartitioning[default]=0
declare -A numaNode
numaNode[default]=-1


function range_to_list() {
# converts 1-3+5-7+9-10 to 1 2 3 5 7 9 10
# used for endpoint options specifying a range of IDs
    local range=$1
    local list=""
    for this_range in `echo $range | sed -e 's/+/ /g'`; do
        if echo $this_range | grep -q "-"; then
            begin=`echo $this_range | awk -F- '{print $1}'`
            end=`echo $this_range | awk -F- '{print $2}'`
        else
            begin=$this_range
            end=$this_range
        fi
        for this_id in `seq $begin $end`; do
            list+=" $this_id"
        done
    done
    echo $list
}

function abort_error() {
    local msg="$1"; shift
    local sync="$1"; shift
    echo "[ERROR] ${msg}" 1>&2
    local msg_file=$(mktemp)
    echo '[{"recipient":{"type":"all","id":"all"},"user-object":{"error":"'$msg'"}}]' >$msg_file
    do_roadblock ${sync} 90 abort messages "${msg_file}"
    abort=1
}

function exit_error() {
    local msg
    msg="$1"
    echo "[ERROR] ${msg}" 1>&2
    exit 1
}

function process_opts() {
    local longopts="validate,endpoint-opts:,endpoint-label:,run-id:,base-run-dir:,image:"
    local longopts+=",roadblock-server:,roadblock-passwd:,roadblock-id:,osruntime:,max-sample-failures:"
    local longopts+=",max-rb-attempts:,endpoint-deploy-timeout:,engine-script-start-timeout:"
    local longopts+=",packrat-dir:,bench-ids:"
    local opts=$(getopt -q -o "" --longoptions "$longopts" -n "getopt.sh" -- "$@");
    if [ $? -ne 0 ]; then
        exit_error "Unrecognized option specified" endpoint-deploy  
    fi
    eval set -- "$opts";
    while true; do
        case "$1" in
            --packrat-dir)
                shift
                packrat_dir="${1}"
                shift
                ;;
            --validate)
                do_validate="1"
                shift;
                ;;
            --endpoint-opts)
                shift;
                endpoint_opts="$1"
                shift;
                ;;
            --endpoint-label)
                shift;
                endpoint_label="$1"
                shift;
                ;;
            --run-id)
                shift;
                run_id="$1"
                shift;
                ;;
            --base-run-dir)
                shift;
                base_run_dir="$1"
                shift;
                ;;
            --image)
                shift;
                image="$1"
                shift;
                for bench_and_image in `echo $image | sed -e 's/,/ /g'`; do
                    bench=`echo $bench_and_image | awk -F:: '{print $1}'`
                    image=`echo $bench_and_image | awk -F:: '{print $2}'`
                    bench_to_image[$bench]=$image
                done
                ;;
            --roadblock-passwd)
                shift;
                rb_passwd="$1"
                cs_rb_opts="$cs_rb_opts --roadblock-passwd=$rb_passwd"
                shift;
                ;;
            --roadblock-id)
                shift;
                rb_id="$1"
                cs_rb_opts="$cs_rb_opts --roadblock-id=$rb_id"
                shift;
                ;;
            --max-sample-failures)
                shift;
                max_sample_failures="$1"
                shift;
                ;;
            --max-rb-attempts)
                shift;
                max_rb_attempts="$1"
                shift;
                ;;
            --endpoint-deploy-timeout)
                shift;
                endpoint_deploy_timeout="$1"
                echo "setting endpoint_deploy_timeout to $endpoint_deploy_timeout"
                shift;
                ;;
            --engine-script-start-timeout)
                shift;
                engine_script_start_timeout="$1"
                echo "setting engine_script_start_timeout to $engine_script_start_timeout"
                shift;
                ;;
            --bench-ids)
                shift;
                bench_ids="$1"
                echo "setting bench_ids to $bench_ids"
                shift;
                for bench_and_range in `echo $bench_ids | sed -e 's/,/ /g'`; do
                    bench=`echo $bench_and_range | awk -F: '{print $1}'`
                    range=`echo $bench_and_range | awk -F: '{print $2}'`
                    echo "bench: [$bench]"
                    echo "range: [$range]"
                    if echo $range | grep -q "-"; then
                        range_start=`echo $range | awk -F- '{print $1}'`
                        range_end=`echo $range | awk -F- '{print $2}'`
                        for id in `seq $range_start $range_end`; do
                            id_to_bench[$id]=$bench
                        done
                    else
                        id_to_bench[$range]=$bench
                    fi
                done
                ;;
            --)
                shift;
                break;
            ;;
            *)
            exit_error "Unexpected argument [$1]" endpoint-deploy
            shift;
            break;
            ;;
        esac
    done
}
if [ -z "$max_sample_failures" ]; then
    max_sample_failures=3
    if [ "do_validate" == "0" ]; then
        echo "[WARNING] --max-sample-failures was not used, so setting to default of $max_sample_failures"
    fi
fi
if [ -z "$max_rb_attempts" ]; then
    max_rb_attempts=1
    if [ "do_validate" == "0" ]; then
        echo "[WARNING] --max-rb-attempts was not used, so setting to default of $max_rb_attempts"
    fi
fi

function process_common_endpoint_opts() {
    typeset -n ref1=$1; shift # caller-provided variable name (call-by-reference)
    local endpoint_opts=$1; shift # endpoint options we process
    local noncommon_endpoint_opts="" # endpoint options we return for endpoint-specific processing
    for opt in `echo $endpoint_opts | sed -e 's/,/ /g'`; do
        arg=`echo $opt| awk -F: '{print $1}'`
        # The $val may have : in it, so don't use awk to get only the second field
        val=`echo $opt | sed -e s/^$arg://`
        case "$arg" in
            cpu-partitioning)
                # cpu-partitioning is per engine:
                # option format::  cpu-partitioning:<engine-label>:<value>
                # <engine-label> can be 'default' to apply to any engine that is not explicitly specified
                # <engine-label> can be an engine type (client, server) and a '-', followed by range(s) of numbers:
                #   client-1-3+5-7+9-11   <-ranges must be separated with '+'
                #TODO: validate correct format of <engine-label>
                name=$(get_opt_field "${val}" "key")
                value=$(get_opt_field "${val}" "value")
                label=`echo $name | awk -F- '{print $1}'`
                range=`echo $name | sed -e s/$label-//`
                if [ ! -z "$name" -a ! -z "$value" ]; then
                    if [ "$label" == "default" ]; then
                        cpuPartitioning["default"]=$value
                    else
                        local list=`range_to_list $range`
                        for this_id in $list; do
                            cpuPartitioning[$label-$this_id]=$value
                        done
                    fi
                else
                    exit_error "Could not properly decode cpu-partitioning for '$val'"
                fi
                ;;
            osruntime)
                # osruntime is per engine:
                # option format:: osruntime:<engine-label>:<value>
                # <engine-label> can be 'default' to apply to any engine that is not explicitly specified
                # <engine-label> can be an engine type (client, server) and a '-', followed by range(s) of numbers:
                #   client-1-3+5-7+9-11   <-ranges must be separated with '+'
                # for backwards compability values in the form of 'osruntime:<value>' will map to 'osruntime:default:<value>'
                # backwards compability transformation
                if ! echo "${val}" | grep -q -e '[a-zA-Z0-9\-]:[a-zA-Z0-9\-]'; then
                    val="default:${val}"
                fi
                name=$(echo "${val}" | awk -F: '{ print $1 }')
                value=$(echo "${val}" | awk -F: '{ print $2 }')
                if [ -z "${name}" -o -z "${value}" ]; then
                    echo "#Could not properly decode osruntime for '${val}'"
                    exit_error "Could not properly decode osruntime for '${val}'"
                fi
                label=`echo $name | awk -F- '{print $1}'`
                range=`echo $name | sed -e s/$label-//`
                if [ "$value" != "chroot" -a "$value" != "podman" ]; then
                    echo "#osruntime '${value}' for '${name}' not supported"
                    exit_error "osruntime '${value}' for '${name}' not supported"
                fi

                if [ "$name" == "default" ]; then
                    osruntime["default"]=$value
                else
                    local list=`range_to_list $range`
                    for this_id in $list; do
                        osruntime[$label-$this_id]=$value
                    done
                fi
                ;;
            numa-node)
                # node-node is per engine:
                # option format:: numa-node:<engine-label>:<value>
                # <engine-label> can be 'default' to apply to any engine that is not explicitly specified
                # <engine-label> can be an engine type (client, server) and a '-', followed by range(s) of numbers:
                #   client-1-3+5-7+9-11   <-ranges must be separated with '+'
                #TODO: validate correct format of <engine-label>
                name=$(get_opt_field "${val}" "key")
                value=$(get_opt_field "${val}" "value")
                label=`echo $name | awk -F- '{print $1}'`
                range=`echo $name | sed -e s/$label-//`
                if [ ! -z "$name" -a ! -z "$value" ]; then
                    if [ "$label" == "default" ]; then
                        numaNode["default"]=$value
                    else
                        local list=`range_to_list $range`
                        for this_id in $list; do
                            numaNode[$label-$this_id]=$value
                        done
                    fi
                else
                    exit_error "Could not properly decode numa-node for '$val'"
                fi
                ;;
            *)
                noncommon_endpoint_opts+=",$opt"
                ;;
        esac
    done
    ref1=`echo $noncommon_endpoint_opts | sed -e s/^,//`
}


function addto_clients_servers() {
    local arg="$1"; shift
    local val="$1"; shift
    for ids in `echo $val | sed -e 's/+/ /g'`; do
        if echo $ids | grep -q -- "-"; then
            range=`echo $ids | sed 's/-/ /'`
            for j in `seq $range`; do
                if [ "$arg" == "clients" -o "$arg" == "client" ]; then
                    clients[$j]="client-$j"
                    let num_clients=$num_clients+1
                elif [ "$arg" == "servers" -o "$arg" == "server" ]; then
                    servers[$j]="server-$j"
                    let num_servers=$num_servers+1
                elif [ "$arg" == "profiler" ]; then
                    collectors[$j]="profiler-$j"
                    let num_collectors=$num_collectors+1
                fi
            done
        else
            if [ "$arg" == "clients" -o "$arg" == "client" ]; then
                clients[$ids]="client-$ids"
                let num_clients=$num_clients+1
            elif [ "$arg" == "servers" -o "$arg" == "server" ]; then
                servers[$ids]="server-$ids"
                let num_servers=$num_servers+1
            elif [ "$arg" == "profiler" ]; then
                collectors[$ids]="profiler-$ids"
                let num_collectors=$num_collectors+1
            fi
        fi
    done
}

function set_total_cpupart() {
    for this_cs_label in ${clients[@]} ${servers[@]}; do
        set +u
        cpu_partitioning=0
        if [ ! -z "${cpuPartitioning[$this_cs_label]}" ]; then
            cpu_partitioning=${cpuPartitioning[$this_cs_label]}
        elif [ ! -z "${cpuPartitioning[default]}" ]; then
            cpu_partitioning=${cpuPartitioning[default]}
        fi
        set -u

        if [ "${cpu_partitioning}" == "1" ]; then
            (( total_cpu_partitions++ ))
        fi
    done
}

function set_osruntime_numanode_cpupart() {
    local this_cs_label=$1
    set +u
    if [ ! -z "${osruntime[$this_cs_label]}" ]; then
        os_runtime=${osruntime[$this_cs_label]}
    else
        os_runtime=${osruntime[default]}
    fi

    if [ ! -z "${cpuPartitioning[$this_cs_label]}" ]; then
        cpu_partitioning=${cpuPartitioning[$this_cs_label]}
    elif [ ! -z "${cpuPartitioning[default]}" ]; then
        cpu_partitioning=${cpuPartitioning[default]}
    fi

    if [ ! -z "${numaNode[$this_cs_label]}" ]; then
        numa_node=${numaNode[$this_cs_label]}
    else
        numa_node=${numaNode[default]}
    fi
    set -u
}

function echo_clients_servers() {
    if [ $num_clients -gt 0 ]; then
        echo "client ${!clients[@]}"
    fi
    if [ $num_servers -gt 0 ]; then
        echo "server ${!servers[@]}"
    fi
    if [ $num_collectors -gt 0 ]; then
        echo "profiler ${!collectors[@]}"
    fi
}

function init_common_dirs() {
    config_dir="${base_run_dir}/config"
    engine_config_dir="${config_dir}/engine"
    engine_bench_cmds_dir="${engine_config_dir}/bench-cmds"
    run_dir="${base_run_dir}/run"
    engine_logs_dir="${run_dir}/engine/logs"
    endpoint_run_dir="${run_dir}/endpoint/${endpoint_label}"
    bootstrap_script="/usr/local/bin/bootstrap"
    engine_run_script="/usr/local/bin/engine-script"
    roadblock_msgs_dir="${endpoint_run_dir}/roadblock-msgs"

    if [ "$do_validate" != 1 ]; then
        mkdir -p "${endpoint_run_dir}"
        mkdir -p "${engine_logs_dir}"
        mkdir -p "${roadblock_msgs_dir}"
    fi
}

function base_req_check() {
    if [ -z "$rb_passwd" -o -z "$rb_id" ]; then
        echo "Not using roadblock to synchronize since some or all options were missing"
        use_rb=0
        cs_rb_opts=""
        rb_do_exit=0
        if [ ${#clients[@]} -gt 1 ]; then
            echo "Refusing to run because roadblock is not being used and number of clients is > 1"
            rb_do_exit=1
        fi
        if [ ${#servers[@]} -gt 0 ]; then
            echo "Refusing to run because roadblock is not being used and servers are used"
            rb_do_exit=1
        fi
        if [ "$rb_do_exit" == "1" ]; then
            exit_error "Exiting do to roadblock/client/server conflict" endpoint_deploy
        fi
    else
        use_rb=1
    fi
    if [ -z "$run_id" ]; then
        exit_error "The run ID was not provided" endpoint-deploy-begin
    fi
    if [ -z "$base_run_dir" ]; then
        exit_error "--base-run-dir was not provided" endpoint-deploy-begin
    fi
    if [ ! -d "$base_run_dir" ]; then
        exit_error "The run directory [$base_run_dir] does not exist" endpoint-deploy-begin
    fi
    if [ ! -e "$config_dir/rickshaw_id.rsa" ]; then
        exit_error "Could not find $config_dir/rickshaw_id.rsa" endpoint-deploy-begin
    fi
    if [ ! -e "$engine_bench_cmds_dir/client/1" ]; then
        exit_error "client bench cmd file $engine_bench_cmds_dir/client/1 not found" endpoint-deploy-begin
    fi
}

function verify_ssh_login() {
    local user host
    user=$1; shift
    host=$1; shift

    do_ssh $user@$host uptime >/dev/null || exit_error "Could not ssh to $host -- did you setup passwordless login using SSH keys?"
}

function do_ssh() {
    local user_host user host ssh_cmd
    user_host=$1; shift
    user=`echo $user_host | awk -F@ '{print $1}'`
    host=`echo $user_host | awk -F@ '{print $2}'`
    ssh_cmd=""
    if [ -z "$user" ]; then
        exit_error "do_ssh: user was blank: $user_host"
    fi
    if [ -z "$host" ]; then
        exit_error "do_ssh: host was blank: $user_host"
    fi
    # the k8s & osp endpoints are the only endpoints (as of now) that doesn't
    # force the user to have root privileges.
    if [ "${endpoint_name}" != "k8s" -a "${endpoint_name}" != "osp" -a "${user}" != "root" ]; then
        ssh_cmd="ssh $ssh_opts $user_host sudo bash -c \"$@\""
    else
        ssh_cmd="ssh $ssh_opts $user_host bash -c \"$@\""
    fi
    $ssh_cmd
    local rc=$?
    return $rc
}

function do_scp() {
    # The following allows for using a non-root user>
    # If a non-root user is used, that user must have root-priv
    # no password prompt required.
    local src dst dst_sudo_cmd dst_path dst_user_host dst_user dst_cmd src_base
    local src_sudo_cmd src_path src_user_host src_user src_sudo_cmd src_cmd
    src_userhost=$1; shift # [<user>@<host>]
    src_path=$1; shift # <path> path can be a dir or file
                       # If a dir, the full dir is used when copied to the destination
    dst_userhost=$1; shift # [<user>@<host>]
    dst_path=$1; shift # <path> path can be a dir or file
                       # if src_path is a dir, dst_path must also be a dir

    if echo $dst_userhost | grep -q -- "@"; then
        dst_sudo_cmd=""
        dst_user=`echo $dst_userhost | awk -F@ '{print $1}'`
        #if [ "$dst_user" != "root" ]; then
        if [ "${endpoint_name}" != "k8s" -a "${endpoint_name}" != "osp" -a "${dst_user}" != "root" ]; then
            local dst_sudo_cmd="sudo"
        fi
        dst_host=`echo $dst_userhost | awk -F@ '{print $2}'`
        dst_cmd="ssh $ssh_opts ${dst_user}@$dst_host $dst_sudo_cmd tar -C $dst_path -xf -"
    else
        dst_cmd="tar -C $dst_path -xf -"
    fi

    src_base=$(dirname ${src_path})
    src_path=$(basename ${src_path})
    if echo $src_userhost | grep -q -- "@"; then
        src_sudo_cmd=""
        src_user=`echo $src_userhost | awk -F@ '{print $1}'`
        if [ "$src_user" != "root" ]; then
            src_sudo_cmd="sudo"
        fi
        src_host=`echo $src_userhost | awk -F@ '{print $2}'`
        src_cmd="ssh ${ssh_opts} ${src_user}@${src_host} ${src_sudo_cmd} tar -C ${src_base} -cf - ${src_path}"
    else
        src_cmd="tar -C ${src_base} -cf - ${src_path}"
    fi

    echo "Going to run:"
    echo "$src_cmd | $dst_cmd"
    $src_cmd | $dst_cmd
}

function do_roadblock() {
    echo "do_roadblock() ARGC: $#"
    echo "do_roadblock() ARGS: $@"
    local label=$1; shift
    local timeout=$1; shift
    local leader="controller"
    local message=""
    local wait_for=""
    local wait_for_log=""
    local do_abort=0

    while [ $# -gt 0 ]; do
        if [ -n "${1}" -a "${1}" == "messages" ]; then
            shift
            message="${1}"; shift
            echo "Going to send this user message file: ${message}"
        elif [ -n "${1}" -a "${1}" == "wait-for" ]; then
            shift
            wait_for="${1}"; shift
            wait_for_log=$(mktemp)
            echo "Going to run this wait-for command: ${wait_for}"
            echo "Going to log wait-for to this file: ${wait_for_log}"
        elif [ -n "${1}" -a "${1}" == "abort" ]; then
            shift
            do_abort=1
            echo "Going to send an abort"
        else
            exit_error "[ERROR]do_roadblock() encountered invalid option parameter(s) [$@]"
        fi
    done

    if [ -z "${message}" ]; then
        echo "Not going to send user message file"
    fi
    if [ -z "${wait_for}" ]; then
        echo "Not going to use wait-for"
    fi
    if [ -z "${label}" ]; then
        exit_error "[ERROR]do_roadblock() label not provided"
    fi
    if [ -z "${timeout}" ]; then
        exit_error "[ERROR]do_roadblock() timeout not provided"
    fi

    local msgs_log_file="$roadblock_msgs_dir/$label.json"
    local cmd=""
    local role="follower"
    ping -w 10 -c 4 localhost || exit_error "Could not ping controller 4 times in 10 seconds"
    cmd="${cmd} /usr/local/bin/roadblock.py --role=${role} --redis-server=localhost"
    cmd="${cmd} --leader-id=${leader} --timeout=${timeout} --redis-password=${rb_passwd}"
    cmd="${cmd} --follower-id=${endpoint_label} --message-log=${msgs_log_file}"
    if [ -n "${message}" ]; then
        cmd="${cmd} --user-message ${message}"
    fi
    if [ -n "${wait_for}" ]; then
        cmd="${cmd} --wait-for \"${wait_for}\""
        cmd="${cmd} --wait-for-log ${wait_for_log}"
    fi
    if [ ${do_abort} -eq 1 ]; then
        cmd="${cmd} --abort"
    fi

    local uuid="${rb_id}:${label}"
    printf "\n\n"
    echo "Starting roadblock [`date`]"
    echo "server: localhost"
    echo "role: ${role}"
    echo "uuid (without attempt ID embedded): ${uuid}"
    echo "timeout: ${timeout}"

    local attempts=0
    local rc=99
    local output=""
    while [ ${attempts} -lt ${max_rb_attempts} -a ${rc} -ne ${rb_exit_success} -a ${rc} -ne ${rb_exit_abort} ]; do
        let attempts=${attempts}+1
        echo "attempt number: ${attempts}"
        echo "uuid: ${attempts}:${uuid}"
        local rb_cmd="${cmd} --uuid ${attempts}:${uuid}"
        echo "going to run this roadblock command: ${rb_cmd}"
        echo "roadblock output BEGIN"
        # use eval to make the quoting behave properly
        eval ${rb_cmd}
        rc=$?
        echo "roadblock output END"
        echo "roadblock exit code: ${rc}"
        if [ -f ${msgs_log_file} ]; then
            echo "messages from roadblock:"
            cat ${msgs_log_file}
        fi
        if [ -n "${wait_for_log}" -a -f "${wait_for_log}" ]; then
            echo "wait-for log:"
            cat ${wait_fir_log}
            rm ${wait_for_log}
        fi
    done

    echo "total attempts: ${attempts}"
    echo "Completed roadblock [`date`]"
    printf "\n\n"

    echo "returning ${rc}"
    return ${rc}
}

function prepare_roadblock_user_msgs_file {
    local iteration_sample_directory=$1; shift
    local roadblock_name=$1; shift

    local pending_tx_msgs=$(/bin/ls -1 ${cs_tx_msgs_dir})
    if [ ! -z "${pending_tx_msgs}" ]; then
        echo "Found queued messages in ${cs_tx_msgs_dir}, preparing them to send"

        mkdir -p ${cs_tx_msgs_dir}-sent
        user_msgs_file="${iteration_sample_directory}/rb-msgs-${roadblock_name}.json"

        echo "[" > "${user_msgs_file}"
        for msg in ${pending_tx_msgs}; do
            # TODO validate JSON schema
            echo "Adding ${msg} to ${user_msgs_file}"
            cat "${cs_tx_msgs_dir}/${msg}" >> "${user_msgs_file}"
            /bin/mv "${cs_tx_msgs_dir}/${msg}" "${cs_tx_msgs_dir}-sent"
            echo "," >> "${user_msgs_file}"
        done
        echo '{"recipient":{"type":"all","id":"all"},"user-object":{"sync":"'${roadblock_name}'"}}]' >> "${user_msgs_file}"

        echo "Contents of ${user_msgs_file}:"
        cat "${user_msgs_file}"
    else
        echo "No queued messages found in ${cs_tx_msgs_dir}"
        user_msgs_file=""
    fi
}

function evaluate_test_roadblock {
    local roadblock_name=$1; shift;
    local roadblock_rc=$1; shift;
    local iter_array_idx=$1; shift;

    if [ ${roadblock_rc} != 0 ]; then
        # something bad happened
        if [ ${roadblock_rc} == ${rb_exit_timeout} ]; then
            printf "[ERROR] roadblock '%s' timed out, attempting to exit and cleanly finish the run\n" "${roadblock_name}"

            quit=1
        elif [ ${roadblock_rc} == ${rb_exit_abort} ]; then
            printf "[WARNING] roadblock '%s' received an abort, stopping sample\n" "${roadblock_name}"
            sample_data_attempt_fail[${iter_array_idx}]=1;

            (( sample_data_failures[${iter_array_idx}]++ ))
            printf "sample failures is now: %d\n", ${sample_data_failures[${iter_array_idx}]}

            if [ ${sample_data_failures[${iter_array_idx}]} -ge ${max_sample_failures} ]; then
                sample_data_complete[${iter_array_idx}]=1

                printf "[ERROR] A maximum of %d failures for iteration %d has been reached\n" \
                       ${sample_data_failures[${iter_array_idx}]} \
                       ${sample_data_iteration_id[${iter_array_idx}]}
            fi

            abort=1
        fi
    fi

    local msgs_log_file="${roadblock_msgs_dir}/${roadblock_name}.json"
    if [ -f "${msgs_log_file}" ]; then
        echo "Found received messages file: ${msgs_log_file}"

        local count=0
        local roadblock_label=$(echo "${roadblock_name}" | awk -F: '{ print $2 }')

        local tmp_message_file=$(mktemp)
        jq -cr '.received[] | select(.payload.message.command == "user-object") | .payload.message' ${msgs_log_file} \
           > ${tmp_message_file}
        while read -u 9 line; do
            let count=${count}+1
            local msg="${roadblock_label}:${count}"
            local outfile="${cs_rx_msgs_dir}/${msg}"

            echo "Found user-object message:"
            echo -e "\tMessage:  ${line}"
            echo -e "\tSaved to: ${outfile}"

            echo "${line}" | jq '."user-object"' > "${outfile}"
        done 9< ${tmp_message_file}
        rm ${tmp_message_file}
    fi
}

function roadblock_exit_on_error() {
    local roadblock_rc=$1; shift

    if [ ${roadblock_rc} != 0 ]; then
        echo "roadblock_exit_on_error()"
        exit ${roadblock_rc}
    fi
}

function process_bench_roadblocks() {
    local endpoint_type=""
    if [ $# -gt 0 ]; then
        endpoint_type=$1; shift
    fi

    do_roadblock "setup-bench-begin" ${default_timeout}
    roadblock_rc=$?
    roadblock_exit_on_error ${roadblock_rc}

    local quit=0
    local abort
    local timeout=$default_timeout
    local total_tests=0

    declare -A sample_data_iteration_id
    declare -A sample_data_sample_id
    declare -A sample_data_failures
    declare -A sample_data_complete
    declare -A sample_data_attempt_num
    declare -A sample_data_attempt_fail

    echo "Initializing data structures:"
    while read -u 9 line; do
        iter_samp=`echo ${line} | awk '{print $1}'`
        iter_id=`echo ${iter_samp} | awk -F- '{print $1}'`
        samp_id=`echo ${iter_samp} | awk -F- '{print $2}'`
        iter_array_idx=${total_tests}
        echo "iter_samp=${iter_samp} iter_id=${iter_id} samp_id=${samp_id} iter_array_idx=${iter_array_idx}"

        sample_data_iteration_id[${iter_array_idx}]=${iter_id}
        sample_data_sample_id[${iter_array_idx}]=${samp_id}
        sample_data_failures[${iter_array_idx}]=0
        sample_data_complete[${iter_array_idx}]=0
        sample_data_attempt_num[${iter_array_idx}]=0
        sample_data_attempt_fail[${iter_array_idx}]=0

        (( total_tests += 1 ))
    done 9< "${engine_bench_cmds_dir}/client/1/start"

    echo "Total tests: ${total_tests}"

    do_roadblock "setup-bench-end" ${default_timeout}
    roadblock_rc=$?
    roadblock_exit_on_error ${roadblock_rc}

    local current_test=0
    while read -u 9 line; do
        if [ $quit -gt 0 ]; then
            break
        fi

        (( current_test += 1 ))

        iter_samp=`echo ${line} | awk '{print $1}'`
        iter_id=`echo ${iter_samp} | awk -F- '{print $1}'`
        samp_id=`echo ${iter_samp} | awk -F- '{print $2}'`
        let iter_array_idx=${current_test}-1
        #echo "iter_samp=${iter_samp} iter_id=${iter_id} samp_id=${samp_id} iter_array_idx=${iter_array_idx}"

        iter_samp_dir="${endpoint_run_dir}/iteration-${iter_id}/sample-${samp_id}"
        cs_msgs_dir="${iter_samp_dir}/msgs"
        cs_tx_msgs_dir="${cs_msgs_dir}/tx" # Messages a client, server, or endpoint wants to transmit
        cs_rx_msgs_dir="${cs_msgs_dir}/rx" # Messages a client, server, or endpoint has received
        for this_dir in "${iter_samp_dir}" "${cs_msgs_dir}" "${cs_tx_msgs_dir}" "${cs_rx_msgs_dir}"; do
            echo "mkdir -p ${this_dir}"
            mkdir -p "${this_dir}" || exit_error "Could not mkdir ${this_dir}"
        done

        abort=0
        while [ $quit -eq 0 -a \
                $abort -eq 0 -a \
                ${sample_data_complete[${iter_array_idx}]} -eq 0 -a \
                ${sample_data_failures[${iter_array_idx}]} -lt ${max_sample_failures} ]; do

            sample_data_attempt_fail[${iter_array_idx}]=0
            (( sample_data_attempt_num[${iter_array_idx}]++ ))

            printf "Starting iteration %d sample %d (test %d of %d) attempt number %d of %d\n" \
                   ${iter_id} \
                   ${samp_id} \
                   ${current_test} \
                   ${total_tests} \
                   ${sample_data_attempt_num[${iter_array_idx}]} \
                   ${max_sample_failures}

            user_msgs_file=""
            rb_name=""
            test_id=$(printf "%d-%d-%d" ${sample_data_iteration_id[${iter_array_idx}]} ${sample_data_sample_id[${iter_array_idx}]} ${sample_data_attempt_num[${iter_array_idx}]})
            rb_prefix=$(printf "%s:" ${test_id})

            ####################################################################
            rb_name=$(printf "%s%s" ${rb_prefix} "infra-start-begin")
            prepare_roadblock_user_msgs_file "${iter_samp_dir}" "${rb_name}"
            do_roadblock "${rb_name}" ${timeout} messages "${user_msgs_file}"
            roadblock_rc=$?
            evaluate_test_roadblock "${rb_name}" ${roadblock_rc} ${iter_array_idx}

            rb_name=$(printf "%s%s" ${rb_prefix} "infra-start-end")
            prepare_roadblock_user_msgs_file "${iter_samp_dir}" "${rb_name}"
            do_roadblock "${rb_name}" ${timeout} messages "${user_msgs_file}"
            roadblock_rc=$?
            evaluate_test_roadblock "${rb_name}" ${roadblock_rc} ${iter_array_idx}
            ####################################################################
            rb_name=$(printf "%s%s" ${rb_prefix} "server-start-begin")
            prepare_roadblock_user_msgs_file "${iter_samp_dir}" "${rb_name}"
            do_roadblock "${rb_name}" ${timeout} messages "${user_msgs_file}"
            roadblock_rc=$?
            evaluate_test_roadblock "${rb_name}" ${roadblock_rc} ${iter_array_idx}

            rb_name=$(printf "%s%s" ${rb_prefix} "server-start-end")
            prepare_roadblock_user_msgs_file "${iter_samp_dir}" "${rb_name}"
            do_roadblock "${rb_name}" ${timeout} messages "${user_msgs_file}"
            roadblock_rc=$?
            evaluate_test_roadblock "${rb_name}" ${roadblock_rc} ${iter_array_idx}
            ####################################################################
            rb_name=$(printf "%s%s" ${rb_prefix} "endpoint-start-begin")
            prepare_roadblock_user_msgs_file "${iter_samp_dir}" "${rb_name}"
            do_roadblock "${rb_name}" ${timeout} messages "${user_msgs_file}"
            roadblock_rc=$?
            evaluate_test_roadblock "${rb_name}" ${roadblock_rc} ${iter_array_idx}

            call_endpoint_specific_function "${endpoint_type}" "test_start" "endpoint-start-end" "${roadblock_msgs_dir}" "${test_id}" "${cs_tx_msgs_dir}"

            rb_name=$(printf "%s%s" ${rb_prefix} "endpoint-start-end")
            prepare_roadblock_user_msgs_file "${iter_samp_dir}" "${rb_name}"
            do_roadblock "${rb_name}" ${timeout} messages "${user_msgs_file}"
            roadblock_rc=$?
            evaluate_test_roadblock "${rb_name}" ${roadblock_rc} ${iter_array_idx}
            ####################################################################
            rb_name=$(printf "%s%s" ${rb_prefix} "client-start-begin")
            prepare_roadblock_user_msgs_file "${iter_samp_dir}" "${rb_name}"
            do_roadblock "${rb_name}" ${timeout} messages "${user_msgs_file}"
            roadblock_rc=$?
            evaluate_test_roadblock "${rb_name}" ${roadblock_rc} ${iter_array_idx}

            msgs_log_file="${roadblock_msgs_dir}/${rb_name}.json"
            if [ -f ${msgs_log_file} ]; then
                next_timeout=`jq -r '.received[] | .payload.message."user-object".timeout ' ${msgs_log_file} | grep -v null`
                if [ ! -z "${next_timeout}" ]; then
                    timeout=${next_timeout}
                    printf "Found new client-start-end timeout value: %s\n" ${timeout}
                else
                    printf "Could not find new client-start-end timeout value!\n"
                fi
            else
                printf "Could not find %s\n" ${msgs_log_file}
            fi

            rb_name=$(printf "%s%s" ${rb_prefix} "client-start-end")
            prepare_roadblock_user_msgs_file "${iter_samp_dir}" "${rb_name}"
            do_roadblock "${rb_name}" ${timeout} messages "${user_msgs_file}"
            roadblock_rc=$?
            evaluate_test_roadblock "${rb_name}" ${roadblock_rc} ${iter_array_idx}
            ####################################################################
            # reset the timeout value in case it was changed
            if [ ${timeout} != ${default_timeout} ]; then
                timeout=${default_timeout}
                printf "Resetting timeout value: %s\n" ${timeout}
            fi

            rb_name=$(printf "%s%s" ${rb_prefix} "client-stop-begin")
            prepare_roadblock_user_msgs_file "${iter_samp_dir}" "${rb_name}"
            do_roadblock "${rb_name}" ${timeout} messages "${user_msgs_file}"
            roadblock_rc=$?
            evaluate_test_roadblock "${rb_name}" ${roadblock_rc} ${iter_array_idx}

            rb_name=$(printf "%s%s" ${rb_prefix} "client-stop-end")
            prepare_roadblock_user_msgs_file "${iter_samp_dir}" "${rb_name}"
            do_roadblock "${rb_name}" ${timeout} messages "${user_msgs_file}"
            roadblock_rc=$?
            evaluate_test_roadblock "${rb_name}" ${roadblock_rc} ${iter_array_idx}
            ####################################################################
            rb_name=$(printf "%s%s" ${rb_prefix} "endpoint-stop-begin")
            prepare_roadblock_user_msgs_file "${iter_samp_dir}" "${rb_name}"
            do_roadblock "${rb_name}" ${timeout} messages "${user_msgs_file}"
            roadblock_rc=$?
            evaluate_test_roadblock "${rb_name}" ${roadblock_rc} ${iter_array_idx}

            rb_name=$(printf "%s%s" ${rb_prefix} "endpoint-stop-end")
            prepare_roadblock_user_msgs_file "${iter_samp_dir}" "${rb_name}"
            do_roadblock "${rb_name}" ${timeout} messages "${user_msgs_file}"
            roadblock_rc=$?
            evaluate_test_roadblock "${rb_name}" ${roadblock_rc} ${iter_array_idx}
            ####################################################################
            rb_name=$(printf "%s%s" ${rb_prefix} "server-stop-begin")
            prepare_roadblock_user_msgs_file "${iter_samp_dir}" "${rb_name}"
            do_roadblock "${rb_name}" ${timeout} messages "${user_msgs_file}"
            roadblock_rc=$?
            evaluate_test_roadblock "${rb_name}" ${roadblock_rc} ${iter_array_idx}

            call_endpoint_specific_function "${endpoint_type}" "test_stop" "server-stop-end" "${roadblock_msgs_dir}" "${test_id}"

            rb_name=$(printf "%s%s" ${rb_prefix} "server-stop-end")
            prepare_roadblock_user_msgs_file "${iter_samp_dir}" "${rb_name}"
            do_roadblock "${rb_name}" ${timeout} messages "${user_msgs_file}"
            roadblock_rc=$?
            evaluate_test_roadblock "${rb_name}" ${roadblock_rc} ${iter_array_idx}
            ####################################################################
            rb_name=$(printf "%s%s" ${rb_prefix} "infra-stop-begin")
            prepare_roadblock_user_msgs_file "${iter_samp_dir}" "${rb_name}"
            do_roadblock "${rb_name}" ${timeout} messages "${user_msgs_file}"
            roadblock_rc=$?
            evaluate_test_roadblock "${rb_name}" ${roadblock_rc} ${iter_array_idx}

            rb_name=$(printf "%s%s" ${rb_prefix} "infra-stop-end")
            prepare_roadblock_user_msgs_file "${iter_samp_dir}" "${rb_name}"
            do_roadblock "${rb_name}" ${timeout} messages "${user_msgs_file}"
            roadblock_rc=$?
            evaluate_test_roadblock "${rb_name}" ${roadblock_rc} ${iter_array_idx}
            ####################################################################

            local sample_result
            if [ ${sample_data_attempt_fail[${iter_array_idx}]} -eq 0 -a \
                 $abort == 0 -a \
                 $quit == 0 ]; then
                sample_data_complete[${iter_array_idx}]=1

                sample_result="successfully"
            else
                sample_result="unsuccessfully"

                if [ $abort != 0 ]; then
                    printf "[WARNING] An abort signal has been encountered for this sample!\n";
                fi

                if [ $quit != 0 ]; then
                    printf "[ERROR] A quit signal has been encountered!\n";
                fi
            fi

            printf "Completed iteration %d sample %d (test %d of %d) attempt number %d of %d %s\n" \
                   ${iter_id} \
                   ${samp_id} \
                   ${current_test} \
                   ${total_tests} \
                   ${sample_data_attempt_num[${iter_array_idx}]} \
                   ${max_sample_failures} \
                   ${sample_result}
        done
    done 9< "$engine_bench_cmds_dir/client/1/start"
}

function process_roadblocks() {
    local endpoint_type=$1; shift
    local new_followers="$@"
    local msg_file=""
    local roadblock_rc

    local msgs_arg=""
    if [ ! -z "$new_followers" ]; then
        echo "pwd: `/bin/pwd`"
        msg_file="$endpoint_run_dir/new-followers.json"
        echo "new_followers: $new_followers"
        echo '[{"recipient":{"type":"all","id":"all"},"user-object":{"new-followers":[' >$msg_file
        echo $new_followers | sed  -re 's/^\s+//' -re 's/\s+$//' -re 's/\s+/,/g' -re 's/([^,]+)/"\1"/g' >>$msg_file
        echo ']}}]' >>$msg_file
        echo "ls: `/bin/ls`"
        msgs_arg="messages ${msg_file}"
    fi


    do_roadblock "endpoint-deploy-begin" ${endpoint_deploy_timeout} ${msgs_arg}
    roadblock_rc=$?
    roadblock_exit_on_error ${roadblock_rc}

    do_roadblock "endpoint-deploy-end" ${endpoint_deploy_timeout}
    roadblock_rc=$?
    roadblock_exit_on_error ${roadblock_rc}


    do_roadblock "engine-init-begin" ${engine_script_start_timeout}
    roadblock_rc=$?
    roadblock_exit_on_error ${roadblock_rc}

    do_roadblock "engine-init-end" ${engine_script_start_timeout}
    roadblock_rc=$?
    roadblock_exit_on_error ${roadblock_rc}


    do_roadblock "get-data-begin" ${default_timeout}
    roadblock_rc=$?
    roadblock_exit_on_error ${roadblock_rc}

    do_roadblock "get-data-end" ${default_timeout}
    roadblock_rc=$?
    roadblock_exit_on_error ${roadblock_rc}


    do_roadblock "collect-sysinfo-begin" ${default_timeout}
    roadblock_rc=$?
    roadblock_exit_on_error ${roadblock_rc}

    call_endpoint_specific_function "${endpoint_type}" "sysinfo" "collect-sysinfo-end"
    if [ -d "${endpoint_run_dir}/sysinfo" ]; then
        mv ${endpoint_run_dir}/sysinfo ${run_dir}/sysinfo/endpoint/${endpoint_label}
    fi

    do_roadblock "collect-sysinfo-end" ${default_timeout}
    roadblock_rc=$?
    roadblock_exit_on_error ${roadblock_rc}


    do_roadblock "start-tools-begin" ${default_timeout}
    roadblock_rc=$?
    roadblock_exit_on_error ${roadblock_rc}

    do_roadblock "start-tools-end" ${default_timeout}
    roadblock_rc=$?
    roadblock_exit_on_error ${roadblock_rc}


    process_bench_roadblocks $endpoint_type


    do_roadblock "stop-tools-begin" ${default_timeout}
    do_roadblock "stop-tools-end" ${default_timeout}


    do_roadblock "send-data-begin" ${default_timeout}
    do_roadblock "send-data-end" ${default_timeout}


    do_roadblock "endpoint-cleanup-begin" ${default_timeout}

    call_endpoint_specific_function "${endpoint_type}" "cleanup" "endpoint-cleanup-end"

    do_roadblock "endpoint-cleanup-end" ${default_timeout}
}

function is_ip() {
    local ip=$1; shift

    if echo "$ip" | egrep --silent '[[:digit:]]{1,3}\.[[:digit:]]{1,3}\.[[:digit:]]{1,3}\.[[:digit:]]{1,3}'; then
        return 0
    elif echo "$ip" | egrep --silent '[[:xdigit:]]{1,4}\:[[:xdigit:]]{1,4}\:[[:xdigit:]]{1,4}\:[[:xdigit:]]{1,4}\:[[:xdigit:]]{1,4}\:[[:xdigit:]]{1,4}\:[[:xdigit:]]{1,4}\:[[:xdigit:]]'; then
        return 0
    else
        return 1
    fi
}

function get_controller_ip() {
    local host endpoint_ip controller_ip

    host=$1
    shift

    if [ -z "${host}" ]; then
        exit_error "No controller hostname provided to determine IP address"
        return 1
    else
        if [ "${host}" == "localhost" ]; then
            # get IPv4 address by forcing it via the grep
            host=$(ip addr show lo | grep "inet\s" | awk '{ print $2 }' | awk -F/ '{ print $1 }')

            if [ -z "${host}" ] || ! is_ip ${host}; then
                exit_error "Failed to map localhost to loopback IP address (got '${host}')"
                return 1
            fi
        fi
    fi

    if is_ip ${host}; then
        if ip addr | grep -q ${host}; then
            # the provided IP address is mine so it is the one to use
            echo ${host}
            return 0
        else
            # the provided IP address is not mine -- so it is the endpoint's
            endpoint_ip=${host}
        fi
    else
        endpoint_ip=$(host ${host} | grep "has address" | head -1 | awk -F"has address " '{ print $2 }')

        if [ -z "${endpoint_ip}" ] || ! is_ip ${endpoint_ip}; then
            exit_error "Failed to determine endpoint IP address (got '${endpoint_ip}')"
            return 1
        fi
    fi

    # Now that we have the endpoint's IP, figure out what controller
    # IP this endpoint will need to use to contact the controller
    controller_ip=$(ip route get ${endpoint_ip} | head -1 | awk -F"src " '{ print $2 }' | awk '{ print $1 }')

    if [ -z "${controller_ip}" ] || ! is_ip ${controller_ip}; then
        exit_error "Failed to determine controller IP address (got '${controller_ip}')"
        return 1
    else
        echo ${controller_ip}
        return 0
    fi
}

function load_json_setting() {
    local query var value

    query="$1"
    typeset -n var=$2

    if [ ${do_validate} != 1 ]; then
        echo "load_json_setting():"
    fi

    value=$(${TOOLBOX_HOME}/bin/get-json-settings.pl --settings "${config_dir}/rickshaw-settings.json.xz" --query ${query})
    if [ $? != 0 ]; then
        echo "available json settings:"
        xzcat "${config_dir}/rickshaw-settings.json.xz"
        exit_error "query '${query}' failed to load a json setting"
    else
        var=${value}
        if [ ${do_validate} != 1 ]; then
            echo "json setting query '${query}' returned '${var}'"
        fi
    fi

    return 0
}

function load_settings() {
    load_json_setting "roadblock.timeouts.default" default_timeout
    load_json_setting "roadblock.timeouts.endpoint-deploy" endpoint_deploy_timeout
    load_json_setting "roadblock.timeouts.engine-start" engine_script_start_timeout
    load_json_setting "roadblock.timeouts.move-data" endpoint_move_data_timeout

    if [ -z "${userenv}" -o "${userenv}" == "default" ]; then
        load_json_setting "userenvs.default" userenv
    fi

    if [ -z "${user}" ]; then
        load_json_setting "endpoints.default.user" user
    fi
}

function call_endpoint_specific_function() {
    local endpoint_type function_postfix function_rc my_function_name endpoint_function_name roadblock_name

    my_function_name="call_endpoint_specific_function"

    endpoint_type=${1}; shift
    function_postfix=${1}; shift
    roadblock_name=${1}; shift

    if [ -z "${roadblock_name}" ]; then
        exit_error "${my_function_name}: roadblock name not defined"
    fi

    if [ -z "${endpoint_type}" ]; then
        abort_error "${my_function_name}: no endpoint type specified" ${roadblock_name}
    fi

    if [ -z "${function_postfix}" ]; then
        abort_error "${my_function_name}: function postfix not defined" ${roadblock_name}
    fi

    endpoint_function_name="endpoint_${endpoint_type}_${function_postfix}"
    if [ "$(type -t ${endpoint_function_name})" == "function" ]; then
        echo "${my_function_name}: about to call '${endpoint_function_name} $@'"
        ${endpoint_function_name} "$@"
        function_rc=$?
        echo "${my_function_name}: ${endpoint_function_name} returned rc=${function_rc}"
        if [ ${function_rc} != 0 ]; then
            abort_error "${my_function_name}: ${endpoint_function_name} returned an error (rc=${function_rc})" ${roadblock_name}
        fi
    else
        abort_error "${my_function_name}: there is no defined function ${endpoint_function_name}" ${roadblock_name}
    fi

    return 0
}

get_benchmark_from_id() {
    local this_id = $1; shift
    echo ${ids_to_bench[$this_id]}
}

function make_osruntime_boostrap_script() {
    # Create a copy of the osruntime-boostrap script with
    # vars specific to this endpoint/cs_label.  Order of
    # args is very important!
    local outfile=$1; shift
    echo "#!/bin/bash"             >$outfile
    echo "run_id=$1"              >>$outfile; shift
    echo "rickshaw_host=$1"       >>$outfile; shift
    echo "endpoint_run_dir=$1"    >>$outfile; shift
    echo "cs_label=$1"            >>$outfile; shift
    echo "base_run_dir=$1"        >>$outfile; shift
    echo "cpu_partitioning=$1"    >>$outfile; shift
    echo "endpoint=$1"            >>$outfile; shift
    echo "osruntime=$1"           >>$outfile; shift
    echo "max_sample_failures=$1" >>$outfile; shift
    echo "max_rb_attempts=$1"     >>$outfile; shift
    echo "rb_passwd=$1"           >>$outfile; shift
    echo "rb_id=$1"               >>$outfile; shift
    echo "ssh_id=\"$1\""          >>$outfile; shift
    echo "image=$1"               >>$outfile; shift
    echo "disable_tools=$1"       >>$outfile; shift
    cat $endpoint_base_dir/osruntime-bootstrap >>$outfile
    chmod +x $outfile
}

function get_opt_field() {
    local input=${1}
    local field=${2}

    case "${field}" in
        "key")
            field="1"
            ;;
        "value")
            field="2-" # return all fields from 2 on, allowing for the delimiter to be a part of the value
            ;;
    esac

    echo "${input}" | cut -d ':' -f ${field}
}

function get_image() {
    local var value
    local type=$1; shift
    local id=$1; shift
    typeset -n var=$1; shift

    if [ "$type" != "client" -a "$type" != "server" ]; then
        # For any engine which is not running a benchmark client or server:
        # We don't care what benchmark is in the image.  We only care that
        # an image exists for the ID.  Since the ID for a non-client/server
        # can exceed the ID range of a benchmark client[/server], (for example
        # there could be a "worker-2" when there is only client-1 and server-1)
        # always force the ID to 1 for purposes of looking up benchmark->image.
        # When we build separate images for tools and benchmarks, this will 
        # change (significantly) and a new method to find the correct image for
        # en engine will be implemented.
        id="1"
    fi
    bench=${id_to_bench[$id]}
    value=${bench_to_image[$bench]}
    echo "image for $type $id is [$value]"
    var=$value
}


