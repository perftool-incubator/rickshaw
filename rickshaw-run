#!/usr/bin/perl
# -*- mode: perl; indent-tabs-mode: nil; perl-indent-level: 4 -*-
# vim: autoindent tabstop=4 shiftwidth=4 expandtab softtabstop=4 filetype=perl
#
# Author: Andrew Theurer
#
# Rickshaw will run a benhcmark for you.  Please see README.md for instructions.


use strict;
use warnings;
use Cwd;
use Data::UUID;
use File::pushd;
use File::Basename;
use File::Temp qw(tempdir);
use File::Copy;
use File::Path qw(make_path);
use JSON::XS;
use JSON::Validator;
use Data::Dumper;

BEGIN {
    if (!(exists $ENV{'TOOLBOX_HOME'} && -d "$ENV{'TOOLBOX_HOME'}/perl")) {
        print "This script requires libraries that are provided by the toolbox project.\n";
        print "Toolbox can be acquired from https://github.com/perftool-incubator/toolbox and\n";
        print "then use 'export TOOLBOX_HOME=/path/to/toolbox' so that it can be located.\n";
        exit 1;
    }
}
use lib "$ENV{'TOOLBOX_HOME'}/perl";
use toolbox::json;
use toolbox::logging;
use toolbox::run;

$toolbox::logging::debug = 0;

my $ug = Data::UUID->new;
my %defaults = ( "num-samples" => 1, "tool-group" => "default", "test-order" => "s",
                 "base-run-dir" => tempdir(), "id" => $ug->create_str(),
                 "max-sample-failures" => 1, "max-rb-attempts" => 1);

my @utilities = ( "packrat" );

my $use_roadblock = 0;
my $use_workshop = 0;
my %bench_config;
my @endpoints;
my %userenvs;
my %run; # A multi-dimensional, nested hash, schema TBD
         # This hash documents what was run.
my $redis_passwd = "flubber"; # TODO: make this cmdline setting
my $rb_bin = "/usr/local/bin/roadblock.py";
my $messages_ref;
my $default_rb_timeout = 240;
my $endpoint_deploy_timeout = 360;
my $client_server_script_timeout = 720;
my $endpoint_move_data_rb_timeout = 300;
(my $hostname_cmd, my $hostname, my $hostname_rc) = run_cmd('hostname');
chomp ($hostname);
my $base_rb_leader_cmd = $rb_bin . " --role=leader --redis-server=localhost" .
                         " --redis-password=" . $redis_passwd;
my $base_rb_follower_cmd = $rb_bin . " --role=follower --redis-server=localhost" .
                           " --redis-password=" . $redis_passwd . "\$abort_opt";
my $config_dir;
my $client_server_config_dir;
my $client_server_bench_cmds_dir;
my $tool_cmds_dir;
my $run_dir;
my $base_endpoint_run_dir;
my $client_server_run_dir;
my $client_server_logs_dir;
my $client_server_archives_dir;
my $client_server_run_script;
my $iterations_dir;
my $rickshaw_project_dir;
my $roadblock_msgs_dir;
my $endpoint_roadblock_opt = "";
my $workshop_roadblock_opt = "";
my %utility_configs;
my %tools_configs;
my @tools_params;
{
    # Get the absolute path of the rickshaw project directory
    my $pushd_dir = pushd(dirname($0));
    $rickshaw_project_dir = getcwd();
}
my $bench_schema_file = $rickshaw_project_dir . "/schema/benchmark.json";
my $tool_schema_file = $rickshaw_project_dir . "/schema/tool.json";
my $run_schema_file = $rickshaw_project_dir . "/schema/run.json";
my $utility_schema_file = $rickshaw_project_dir . "/schema/utility.json";
my $bench_params_schema_file = $rickshaw_project_dir . "/schema/bench-params.json";
my $roadblock_exit_success = 0;
my $roadblock_exit_timeout = 3;
my $roadblock_exit_abort = 4;
my $roadblock_exit_input = 2;

my @tests;
my %clients_servers;
my @rb_cs_ids; # unique IDs for roadblock
my $abort_test_id;

sub usage {
    print "\nusage:\n\n";
    print "--json-validator        Path to json schema validation utility\n";
    print "--engine-dir            Directory where the engine project exists\n";
    print "--workshop-dir          Directory where workshop project exists\n";
    print "--packrat-dir           Directory where the packrat project exists\n";
    print "--roadblock-dir         Directory where workshop project exists\n";
    print "--bench-dir             Directory where benchmark helper project exists\n";
    print "--bench-params          File with benchmark parameters to use\n";
    print "--tools-dir             Directory where *all* tool subprojects exist (like \$CRUCIBLE_HOME/subprojects/tools)\n";
    print "--tool-params           File with tool parameters to use\n";
    print "--num-samples           The number of sample exeuctions to run for each benchmark iteration\n";
    print "--max-sample-failures   The total number of benchmark sample executions that are tolerated\n";
    print "--test-order            's' = run all samples of an iteration first\n";
    print "                        'i' = run all iterations of a sample first\n";
    print "                        'r' = run a sample from a random iteration one at a time (ie. chaos mode)\n\n";
    print "--max-rb-attempts       The number of times to try a given roadblock\n";
}

sub find_files {
    my $path = shift;

    my @files;

    if (-d $path) {
        opendir(DH, $path);
        my @entries = readdir(DH);
        close(DH);
        foreach my $entry (@entries) {
            my $entry_path = $path . '/' . $entry;

            if (($entry =~ /^\.$/) ||
                ($entry =~ /^\.\.$/) ||
                ($entry =~ /^\.git$/)) {
                next;
            }

            if (-d $entry_path) {
                push(@files, @{find_files($entry_path)})
            } elsif (-e $entry_path) {
                push (@files, $entry_path);
            }
        }
    } elsif (-e $path) {
        push (@files, $path);
    }

    return(\@files);
}

sub roadblock_leader {
    if ($use_roadblock) {
        my $attempts = 0;
        my $rc = 99;
        my $file_rc;
        my $label = shift;
        my $timeout = shift;
        my $role = "leader";
        my $uuid = $run{'id'} . ":" . $label;
        # save $_[0] for by ref later to store json ref
        my $follower_param = "";
        for (my $i=1; $i < scalar @_; $i++) {
            $follower_param .= " --followers=" . $_[$i];
        }
        my $msgs_file = $roadblock_msgs_dir . "/" . $label . ".json";
        (my $date_cmd, my $date, my $date_rc) = run_cmd('date');
        chomp $date;
        printf "Roadblock: %s ", $date;
        while ($attempts < $run{'max-rb-attempts'} and $rc != $roadblock_exit_success and $rc != $roadblock_exit_abort) {
            $attempts++;
            my $this_uuid = $attempts . ":" . $uuid;
            printf "role: %s ", $role;
            printf "attempt number: %d ", $attempts;
            printf "uuid: %s\n", $this_uuid;
            my $cmd = $base_rb_leader_cmd .
                    " --leader-id=controller" .
                    " --uuid=" . $this_uuid .
                    " --timeout=" . $timeout .
                    " --message-log=" . $msgs_file .
                    $follower_param;
            debug_log(sprintf "roadblock leader command:%s\n", $cmd);
            ($cmd, my $output, $rc) = run_cmd($cmd);
            debug_log(sprintf "roadblock leader rc:%s\n", $rc);
            debug_log(sprintf "roadblock leader output:\n%s\n", join("\n", $output));
            ($file_rc, $_[0]) = get_json_file($msgs_file);
            if ($file_rc > 0 or ! defined $_[0]) {
                print "Could not open the message file\n";
                exit 1;
            }
            if ( $rc != $roadblock_exit_success) {
                printf "roadblock output BEGIN\n";
                printf "%s", join("\n", $output);
                printf "roadblock rc: %d\n", $rc;
                printf "roadblock output END\n";
            }
            if ( $rc == $roadblock_exit_abort ) {
                printf "roadblock messages\n";
                foreach my $msg (@{ $_[0]{'received'} }) {
                    if (exists $$msg{'payload'}{'message'}{'user-object'} and exists $$msg{'payload'}{'message'}{'user-object'}{'error'}) {
                        printf "\nError from %s:\n%s\n\n", $$msg{'payload'}{'sender'}{'id'}, $$msg{'payload'}{'message'}{'user-object'}{'error'};
                    }
                }
            }
        }
        if ($rc == $roadblock_exit_abort or $rc == $roadblock_exit_success) {
            ($file_rc, $_[0]) = get_json_file($msgs_file);
            if ($file_rc > 0 or ! defined $_[0]) {
                print "Could not open the message file\n";
                exit 1;
            }
            return $rc;
        } else {
            # These fatal errors where we can't clean up with sending roadblocks.
            # TODO: try to signal endpoints to clean up what they can.
            exit 1;
        }
    } else {
        return 0;
    }
}

sub dump_params {
    my $default_role = 'client';
    my $params_ref = shift;
    my $cs_id = shift;
    # fallback to client engine by default when engine arg is undefined
    # (dump_params might be called without engine arg)
    my $engine = shift // $default_role;
    my $params_str = "";

    foreach my $param (@{ $params_ref }) {
        my $arg = $$param{'arg'};
        my $val = $$param{'val'};
        my $id;
        if (exists $$param{'id'}) {
            $id = $$param{'id'};
        }
        # fallback to client role when role is undefined in json
        my $role = $$param{'role'} // $default_role;

        if (! defined $id or (defined $cs_id and $id eq $cs_id)) {
            # only dump when role=engine or role=all
            if ( $role eq $engine || $role eq 'all') {
                if (defined $val && length $val) {
                    if (defined $cs_id) {
                        $val =~ s/\%client-id\%/$cs_id/;
                    }
                    $params_str .= " --" . $arg . "=" . $val;
                } else {
                    $params_str .= " --" . $arg;
                }
            }
        }
    }
    $params_str =~ s/^\s//;
    return $params_str;
}

sub file_newer_than {
    my $file = shift;
    my $epoch_sec = shift;
    {
        (my $cmd, my $file_time, my $cmd_rc) = run_cmd("/bin/ls -l --time-style=+%s $file");
        chomp($file_time);
        # -rwxrwxr-x. 1 someuser somegroup 4656 1582742663 client-server-script
        if ($file_time =~ /\S+\s+\S+\s+\S+\s+\S+\s+\S+\s+(\d+)\s+.*/) {
            if ($1 > $epoch_sec) {
                return 1;
            }
        }
    }
    return 0;
}

sub add_endpoint {
    my $endpoint_ref = shift;
    my $type = shift;
    my $opts = shift;
    my $num = 1;
    for my $entry (@$endpoint_ref) {
        $num++ if ($$entry{'type'} eq $type);
    }
    my %endpoint = ( 'type' => $type, 'opts' => $opts, 'label' => $type . "-" . $num);
    push(@$endpoint_ref, \%endpoint);
}

sub dump_endpoint_types {
    my $endpoint_ref = shift;
    my @labels;
    foreach my $endpoint (@$endpoint_ref) {
        push(@labels, $$endpoint{'type'})
    }
    return @labels;
}

sub dump_endpoint_labels {
    my $endpoint_ref = shift;
    my @labels;
    foreach my $endpoint (@$endpoint_ref) {
        push(@labels, $$endpoint{'label'})
    }
    return @labels;
}

sub dir_entries {
    my $dir = shift;
    my $pattern = shift;
    my @entries;
    if (! -e $dir) {
        die "The directory does not exist: $dir";
    }
    opendir(DH, $dir);
    @entries =  readdir(DH);
    if (defined $pattern) {
        @entries =  grep(/$pattern/, @entries);
    }
    close DH;
    return @entries;
}

sub build_container_image {
    my $userenv = shift;
    my $image_url; # What we will return
    if ($use_workshop) {
        # First, calculate the image ID, which is a md5sum of all the
        # image requirementi jsons.
    
        # There are potentially several requirement jsons, the first
        # being the one that defines the req for client-server-scrtipt
        # and roadblock, below:
        #
        # We want to avoid adding content to the image that changes
        # with each invocation of rickshaw because we want to cache
        # these images So, we should not include anything
        # like "client-server-commands" because this changes every time
        # rickshaw is run.
        my $cs_conf_file = $config_dir . "/cs-conf.json";
        my %cs_conf = (
                        'workshop' => {
                            'schema' => {
                                'version' => '2020.04.30'
                            }
                        },
                        'config' => {
                            'entrypoint' => [ "/bin/sh", "-c", "/usr/local/bin/bootstrap" ],
                            'labels' => [ 'quay.expires-after=2w' ],
                            'envs' => [ 'TOOLBOX_HOME=/opt/toolbox' ]
                        }
                    );
        my $cs_req_file = $config_dir . "/cs-req.json";
        my %cs_req = (
                        'workshop' => {
                            'schema' => {
                                'version' => '2020.03.02'
                            }
                        },
                        'userenvs' => [
                            {
                                'name' => 'default',
                                    'requirements' => [
                                        'toolbox'
                                    ]
                            }
                        ],
                        'requirements' => [
                            {
                                'name' => 'toolbox',
                                'type' => 'files',
                                'files_info' => {
                                    'files' => [
                                        {
                                            'src' => $ENV{'TOOLBOX_HOME'},
                                            'dst' => '/opt/toolbox'
                                        }
                                    ]
                                }
                            }
                        ] 
                    );
        if ($use_roadblock) {
            my %rb_req = (  'name' => 'roadblock-client',
                            'type' => 'files',
                            'files_info' => {
                                'files' => [
                                    {
                                        'src' => $run{'roadblock-dir'} . "/roadblock.py",
                                        'dst' => '/usr/local/bin/'
                                    }
                                ] 
                            }
                        );
            push(@{ $cs_req{'requirements'} }, \%rb_req);
            push(@{ $cs_req{'userenvs'}[0]{'requirements'} }, "roadblock-client");
        }
        if (put_json_file($cs_conf_file, \%cs_conf) > 0) {
            printf "build_container_image(): put_json_file() failed\n";
            exit 1;
        }
        if (put_json_file($cs_req_file, \%cs_req) > 0) {
            printf "build_container_image(): put_json_file() failed\n";
            exit 1;
        }
        my $workshop_cmd = $run{'workshop-dir'} . "/workshop.pl" .
            # " --skip-update=true " .
            " --log-level verbose " .
            " --config " . $cs_conf_file .
            " --userenv " . $rickshaw_project_dir . "/userenvs/" . $userenv . ".json" .
            " --requirements " . $run{'bench-dir'} . "/workshop.json" .
            " --requirements " . $run{'engine-dir'} . "/workshop.json" .
            " --param %bench-dir%=" . $run{'bench-dir'} .
            " --param %engine-dir%=" . $run{'engine-dir'} .
            " --param %rickshaw-dir%=" . $rickshaw_project_dir .
            " --requirements " . $cs_req_file .
            $workshop_roadblock_opt .
            " 2>&1";
        foreach my $utility (@utilities) {
            if (exists $run{$utility . '-dir'}) {
                my $utility_req_file = $run{$utility . '-dir'} . "/workshop.json";
                if (-e $utility_req_file) {
                    $workshop_cmd .= " --requirements " . $utility_req_file . " ";
                }
            }
        }
        foreach my $tool_entry (@tools_params) {
            $workshop_cmd .= " --requirements " . $run{'tools-dir'} . "/" .
                $$tool_entry{'tool'} . "/workshop.json ";
        }
        (my $cmd, my $cmd_output, my $cmd_rc) = run_cmd("$workshop_cmd --label config-analysis --dump-config true");
        my @config_analysis_output = split(/\n/, $cmd_output);
        if (open(CONFIG_ANALYSIS_FH, ">", $run_dir . "/workshop.dump-config.out")) {
            printf CONFIG_ANALYSIS_FH "%s\n", join("\n", @config_analysis_output);
            close(CONFIG_ANALYSIS_FH);
        } else {
            print "Failed to open %s/workshop.dump-config.out for writing\n", $run_dir;
        }
        my $break_line = 0;
        for (my $i=0; $i<scalar(@config_analysis_output); $i++) {
            if ($config_analysis_output[$i] =~ /Config dump:/) {
                $break_line = $i;
            }
        }
        splice(@config_analysis_output, 0, $break_line+1);

        # create a list of files to include in hash calculation
        my @files = ($run{'workshop-dir'} . "/workshop.pl",
                     $run{'workshop-dir'} . "/schema.json");
        # add to the file list all the files that workshop identifies
        # as being copied into the userenv
        ($cmd, $cmd_output, $cmd_rc) = run_cmd("$workshop_cmd --label files-listing --dump-files true");
        my @files_dump_output = split(/\n/, $cmd_output);
        if (open(FILES_DUMP_FH, ">", $run_dir . "/workshop.dump-files.out")) {
            printf FILES_DUMP_FH "%s\n", join("\n", @files_dump_output);
            close(FILES_DUMP_FH);
        } else {
            print "Failed to open %s/workshop.dump-files.out\n", $run_dir;
        }
        $break_line = 0;
        for (my $i=0; $i<scalar(@files_dump_output); $i++) {
            if ($files_dump_output[$i] =~ /Files dump:/) {
                $break_line = $i
            }
        }
        splice(@files_dump_output, 0, $break_line+1);
        foreach my $dumped_file (@files_dump_output) {
            if ($dumped_file !~ /^\[VERBOSE\]|^replacing/) {
                debug_log(sprintf "found file from workshop [%s]\n", $dumped_file);

                my $real_path = Cwd::realpath($dumped_file);
                if ($real_path ne $dumped_file) {
                    debug_log(sprintf "file from workshop [%s] is a link to [%s]\n", $dumped_file, $real_path);
                    $dumped_file = $real_path;
                }

                if (-f $dumped_file) {
                    push(@files, $dumped_file);
                } elsif (-d $dumped_file) {
                    debug_log(sprintf "file from workshop [%s] is actually a directory...\n", $dumped_file);
                    my @found_files = @{find_files($dumped_file)};
                    foreach my $found_file (@found_files) {
                        debug_log(sprintf "found file [%s]\n", $found_file);
                        push(@files, $found_file);
                    }
                }
            }
        }

        # compute an md5 hash of relevant information to identify the
        # userenv
        my $md5 = Digest::MD5->new;
        my $coder = JSON::XS->new->canonical;
        my $js = $coder->encode(\%cs_req);
        $md5->add(join("", @config_analysis_output));
        for my $file (@files) {
            open(my $fh, $file);
            binmode($fh);
            $md5->addfile($fh);
            close($fh);
        }
        my $image_md5 = $md5->hexdigest;
        my $workshop_image = $userenv . "_" . $image_md5;
        my $image_tag = $image_md5;
        my $skip_registry_auth = 0;
        my $image_found = 0;
        my $output;
        $image_url = $run{'reg-repo'} . ":" . $image_tag;
        if ($image_url =~ /^dir:/) {
            $image_url =~ /^dir:(.*)/;
            my $image_dir = $1;
            if (! -d $image_dir) {
                printf "Creating local registry directory: %s\n", $image_dir;
                make_path($image_dir, { verbose => 1, error => \my $err } );
                if ($err && @$err) {
                    print "make_path: encountered errors:\n";
                    for my $diag (@$err) {
                        print Dumper $diag;
                    }
                }
            }
        }
        if (! exists $run{'reg-tls-verify'}) {
            $run{'reg-tls-verify'} = "true";
        } elsif ($run{'reg-tls-verify'} ne "true" && $run{'reg-tls-verify'} ne "false") {
            printf "WARNING: Invalid value found for reg-tls-verify, defaulting to 'true'\n";
            $run{'reg-tls-verify'} = "true";
        }
        my $tls_verify = "--tls-verify=" . $run{'reg-tls-verify'};
        if ($run{'reg-auth'} eq "") {
            printf "Disabling registry authorization due to empty 'reg-auth' variable\n";
            $skip_registry_auth = 1;
        }
        my $skopeo_url;
        if (($image_url =~ /^dir:/) || ($image_url =~ /^docker:\/\//)) {
            $skopeo_url = $image_url;
        } else {
            $skopeo_url = "docker://" . $image_url;
        }
        $cmd = "skopeo inspect " . $tls_verify . " " . $skopeo_url . " 2>&1";
        debug_log(sprintf "running: %s\n", $cmd);
        ($cmd, $output, $cmd_rc) = run_cmd($cmd);
        my $push_cmd = "buildah";
        if (! $skip_registry_auth) {
            $push_cmd .= " --authfile " . $run{'reg-auth'};
        }
        $push_cmd .= " push " . $tls_verify . " localhost/workshop/$workshop_image $image_url";
        my $rmi_cmd = "buildah rmi localhost/workshop/$workshop_image";
        if ($cmd_rc == 0) {
            printf "Image was found at %s:\n", $image_url;
            debug_log(sprintf "%s\n", $output) if defined $output;
            $image_found = 1;
        } else {
            printf "Image was not found at %s\n", $image_url;
            debug_log(sprintf "%s\n", $output) if defined $output;
            printf "Checking for local workhop image\n";
            # TODO: get json from buildah and search properly instead of this:
            ($cmd, $output, my $rc) = run_cmd("buildah images | grep -v REPOSITORY | awk '{print \$1}' | grep -- \"^localhost/workshop/$workshop_image\"");
            if ($rc > 0) {
                printf "Local workshop image was also not found:\n";
                printf "%s\n", $output;
            } else {
                $image_found = 1;
                printf "Found local workshop image, pushing to %s\n", $image_url;
                print $push_cmd . "\n";
                ($push_cmd, my $output, my $rc) = run_cmd($push_cmd);
                if ($rc > 0) {
                    die "Pushing workshop image localhost/workshop/$workshop_image to $image_url failed:\n" . $output;
                }
            }
        }
        if (!$image_found) {
            my $workshop_image_id;
            $workshop_cmd .= " --label " . $image_md5;
            printf "Going to generate a new client-server container image with this workshop cmd:\n\n %s\n", $workshop_cmd;
            printf "This may take a few minutes\n";
            ($workshop_cmd, my $workshop_output, my $workshop_rc) = run_cmd($workshop_cmd);
            my @workshop_output = split(/\n/, $workshop_output);
            if (open(WORKSHOP_LOG_FH, ">", $run_dir . "/workshop.out")) {
                printf WORKSHOP_LOG_FH "%s\n", join("\n", @workshop_output);
                close(WORKSHOP_LOG_FH);
            } else {
                printf "Failed to open " . $run_dir . "/workshop.out for writing\n";
            }
            if ($workshop_rc > 0) {
                printf "Workshop build failed:\n";
                printf "%s\n", join("\n", @workshop_output);
                exit 1;
            }
            debug_log(sprintf "%s\n", join("\n", @workshop_output));
            # Becasue there can be a lot of non-JSON debug/info stuff in the output before the
            # actual JSON, find the JSON by starting at the end and scanning backwards
            my $workshop_json = "";
            for (my $i = scalar @workshop_output - 1; $i > 0; $i--) {
                $workshop_json = $workshop_output[$i] . $workshop_json;
                # Break out if we found all of the JSON
                # In this case the JSON begins with an array '['
                last if ($workshop_output[$i] eq "[");
            }
            my $coder = JSON::XS->new;
            my $workshop_ref = $coder->decode($workshop_json);
            $workshop_image_id = $$workshop_ref[0]{'id'};
            printf "Workshop complete.  New image has image id of '%s'.\n", $workshop_image_id;
            printf "Now pushing to container registry with this command:\n%s\n", $push_cmd;
            ($push_cmd, my $output, my $buildah_rc) = run_cmd($push_cmd);
            if ($buildah_rc > 0) {
                printf "Pushing workshop image failed:\n%s\n", $output;
                exit 1;
            } else {
                printf "Removing local container with this command:\n%s\n", $rmi_cmd;
                ($rmi_cmd, $output, $buildah_rc) = run_cmd($rmi_cmd);
                if ($buildah_rc > 0) {
                    printf "Removing workshop image failed:\n%s\n", $output;
                    exit 1;
                }
            }
        }
    }
    return $image_url;
}

sub run_tests {
    my $quit = 0;
    my $abort_run_on_iter_fail = 0;
    my @sample_failures;
    for (my $tid = 0; $tid < scalar @tests; $tid++) {
        last if ($quit > 0);
        my $iter_id = $tests[$tid]{'iteration-id'};
        my $samp_id = $tests[$tid]{'sample-id'};
        my $iter_array_idx = $iter_id - 1;
        my $test_id = $iter_id . "-" . $samp_id;
        my $timeout = $default_rb_timeout;
        my $this_attempt_num = 1;
        my $sample_complete = 0;
        if (! defined $sample_failures[$iter_array_idx]) {
            $sample_failures[$iter_array_idx] = 0;
        }
        while ($sample_complete == 0 and $sample_failures[$iter_array_idx] < $run{'max-sample-failures'}) {
            my $this_attempt_fail = 0;
            printf "Iteration %d sample %d (test %d of %d) attempt number %d\n", $iter_id, $samp_id, $tid+1, scalar(@tests), $this_attempt_num;
            my @syncs;
            my @stop_syncs;
            for my $start_stop (qw(start stop)) {
                if ($start_stop eq "start") {
                    @syncs = (qw(infra server endpoint client));
                } else {
                    @syncs = @stop_syncs;
                }
                for my $sync (@syncs) {
                    my $sync_point = $sync . "-" . $start_stop;
                    if ($start_stop eq "start") {
                        # Build the stop syncs as we go.  If during the start syncs we abort early,
                        # we will only have to do a portion of stop syncs.
                        unshift(@stop_syncs, $sync);
                    }
                    my $messages_ref;
                    my $label = $test_id . "-" . $this_attempt_num . ":" . $sync_point;
                    my $rc = roadblock_leader($label, $timeout, $messages_ref, (@rb_cs_ids, dump_endpoint_labels(\@endpoints)));
                    if ($rc > 0) {
                        if ($rc == $roadblock_exit_abort) {
                            printf "[WARNING]iteration %d sample %d had an abort from %s\n", $iter_id, $samp_id, $sync_point;
                            $this_attempt_fail = 1;
                            $sample_failures[$iter_array_idx]++;
                            printf "sample_failures[%d] is now: %d\n", $iter_array_idx, $sample_failures[$iter_array_idx];
                            if ($sample_failures[$iter_array_idx] >= $run{'max-sample-failures'}) {
                                printf "setting sample_complete to 1\n";
                                $sample_complete = 1;
                                printf "[ERROR]All A maximum of %d failures for iteration %d have been " .
                                    "reached, failing this iteration\n", $run{'max-sample-failures'},
                                    $iter_id;
                            }
                            if ($abort_run_on_iter_fail == 1) {
                                $abort_test_id = $tid;
                                $tid = scalar @tests; # Force break from outer loop
                                        $quit = 1;
                            }
                            # Don't continue with remaining syncs if this is start.
                            # Stop syncs are automatically reduced because that array is built
                            # as progression is made with start syncs.
                            last if ($start_stop eq "start");
                        } else {
                            # If a roadblock fails, this is fatal and the run cannot continue
                            printf "[ERROR]roadblock for %s failed, exiting\n", $sync_point;
                            exit 1;
                        }
                    } else {
                        if ($this_attempt_fail == 0 and $sync_point eq "server-stop") {
                            $sample_complete = 1;
                            printf "Sample %d completed successfully with %d failed attempts " .
                                "(%d total sample failures for this iteration)\n",
                                $samp_id, $this_attempt_num - 1, $sample_failures[$iter_array_idx];
                        }
                        $timeout = $default_rb_timeout;
                        my %messages = %{ $messages_ref };
                        if ( $sync_point eq "client-start" and exists $messages{'received'} ) {
                            for my $message (@{ $messages{'received'} }) {
                                if (exists $$message{'payload'}{'message'}{'user-object'}{'timeout'}) {
                                    printf "found new timeout value: %s\n", $$message{'payload'}{'message'}{'user-object'}{'timeout'};
                                    $timeout = $$message{'payload'}{'message'}{'user-object'}{'timeout'};
                                    printf "Assigning new timeout with padding for next roadblock: %d\n", $timeout;
                                }
                            }
                        }
                    }
                }
            }
            $this_attempt_num++;
        }
    }
}

# Apply envinronment variables
foreach my $e (qw(RS_NAME RS_EMAIL RS_TAGS RS_DESC RS_REG_AUTH RS_REG_REPO RS_REG_TLS_VERIFY)) {
    if (exists $ENV{$e}) {
        my $var = $e;
        $var =~ s/^RS_//;
        $var =~ tr/[A-Z]/[a-z]/;
        $var =~ s/_/\-/g;
        debug_log(sprintf("Found envornment variable: %s, assigning \"%s\" to %s\n", $e, $ENV{$e}, $var));
        $run{$var} = $ENV{$e};
    }
}

sub process_cmdline() {
    while (scalar @ARGV > 0) {
        my $p = shift @ARGV;
        debug_log(sprintf "processing \@ARGV, param: [%s]\n", $p);
        my $arg;
        my $val;
        if ( $p =~ /^\-\-(\S+)/ ) {
            $arg = $1;
            if ( $arg =~ /^(\S+)=(.*)/ ) { # '--arg=val'
                $arg = $1;
                $val = $2;
            } else { # '--arg val'
                $val = shift @ARGV;
            }
        } else {
            print "[ERROR]malformed cmdline parameter: %s\n";
            usage;
            exit 1;
        }
        debug_log(sprintf "processing \@ARGV, arg is: [%s], val is: [%s]\n", $arg, $val);
        if ($arg eq "endpoint") {
            $val =~ /^(\w+),(.*)$/;
            add_endpoint(\@endpoints, $1, $2);
        } elsif ($arg =~ /^debug$/) {
            $toolbox::logging::debug = $val;
        } elsif ($arg =~ /^help$/) {
            usage;
            exit 0;
        } elsif ($arg =~ /^base-run-dir$|^workshop-dir$|^packrat-dir$|^bench-dir$|^roadblock-dir$|^tools-dir$|^engine-dir$/ or
                $arg =~ /^run-id$|^id$|^bench-params$|^tool-params$|^bench-params$|^max-rb-attempts$/ or
                $arg =~ /^test-order$|^tool-group$|^num-samples$|^max-sample-failures$|^name$/ or
                $arg =~ /^reg-(auth|repo)$/ or
                $arg =~ /^email$|^desc$/) {
            debug_log(sprintf "argument: [%s]\n", $arg);
            $run{$arg} = $val;
        } elsif ($arg =~ /^tags$/) {
            debug_log(sprintf "argument: [%s]\n", $arg);
            if (! exists($run{'tags'})) {
                $run{'tags'} = [];
            }
            foreach my $this_tag (split(/,/, $val)) {
                if ($this_tag =~ /(\S+):(\S+)/) {
                    my %tag = ('name' => $1, 'val' => $2);
                    push(@{ $run{'tags'} }, \%tag);
                } else {
                    printf "ERROR: format for tag is not valid: %s\n", $this_tag;
                    exit 1;
                }
            }
        } else {
            printf "[ERROR]argument not valid: [%s]\n", $arg;
            usage;
            exit 1;
        }
    }
    # Apply defaults
    foreach my $p (keys %defaults) {
        if (! exists $run{$p}) {
            debug_log(sprintf "applying default value [%s] for %s\n", $defaults{$p}, $p);
            $run{$p} = $defaults{$p};
        }
    }
}

sub validate_controller_env() {
    if (defined $run{'roadblock-dir'} and -e $run{'roadblock-dir'} . "/roadblock.py") {
        copy($run{'roadblock-dir'} . "/roadblock.py", $rb_bin);
        chmod 0755, "$rb_bin";
        $use_roadblock = 1;
    }
    if (defined $run{'workshop-dir'} and -e $run{'workshop-dir'} . "/workshop.pl") {
        $use_workshop = 1;
        if ( ! exists $run{'reg-repo'} ) {
            die "You must define a container repository (--reg-repo or RS_REG_REPO = \"<fqdn>/<project>/<repo>\") to use rickshaw with workshop"
        }
        if ( ! exists $run{'reg-auth'} ) {
            die "You must define a path to a authorizaton file (--reg-auth or RS_REG_AUTH) to use rickshaw with workshop"
        }
    }
    exists $run{'tools-dir'} || die "[ERROR]You must use " .
                                    "--tools-dir=/path/to/tools/base/subproject-dir " .
                                    "(\$CRUCIBLE_HOME/subprojects/tools)\n";
}

sub load_bench_params() {
    # Load the bench config and user params
    exists $run{'bench-dir'} || die "[ERROR]You must use --bench-dir=/path/to/benchmark-subproject\n";
    my $bench_config_file = $run{'bench-dir'} . "/rickshaw.json";
    my $rc;
    if (-e $bench_config_file) {
        ($rc, my $bench_config_ref) = get_json_file($bench_config_file, $bench_schema_file);
        if ($rc > 0 or ! defined $bench_config_ref) {
            print "Could not open the bench config file\n";
            exit 1;
        }
        %bench_config = %$bench_config_ref;
        if (exists $bench_config{'benchmark'}) {
            printf "Preparing to run %s\n", $bench_config{'benchmark'};
            $run{'benchmark'} = $bench_config{'benchmark'};
        } else {
            print "[ERROR]benchmark was not defined in %s\n", $bench_config_file;
            exit 1;
        }
    } else {
        printf "[ERROR]benchmark subproject config file %s was not found\n", $bench_config_file;
        exit 1;
    }
    exists $run{'bench-params'} || die "[ERROR}You must use " .
                                    "--bench-params=/path/to/benchmark-params.json\n";
    ($rc, my $param_sets_ref) = get_json_file($run{'bench-params'}, $bench_params_schema_file);
    if ($rc > 0 or ! defined $param_sets_ref) {
        print "Could not open the bench params file\n";
        exit 1;
    }
    my @param_sets = @{ $param_sets_ref };
    # TODO: verify user params schema
    $run{'iterations'} = ();
    my $iter_id = 0;
    for my $params (@param_sets) {
        $run{'iterations'}[$iter_id]{'params'} = $params;
        $iter_id++;
    }
}

sub load_tool_params() {
    my $rc;
    if (not exists $run{'tool-params'} ) {
        $run{'tool-params'} = $rickshaw_project_dir . "/config/tool-params.json";
    }
    # TODO: need schema for tool-params
    ($rc, my $json_ref) = get_json_file($run{'tool-params'});
    if ($rc > 0 or ! defined $json_ref) {
        print "Could not open the tool params file\n";
        exit 1;
    }
    @tools_params = @{ $json_ref };
    # Load a tool configuration for every tool the user is asking for
    foreach my $tool_entry (@tools_params) {
        my $tool_name = $$tool_entry{'tool'};
        my $this_tool_config = $run{'tools-dir'} . "/" . $tool_name . "/rickshaw.json";
        my ($rc, $json_ref) = get_json_file($this_tool_config, $tool_schema_file);
        if ($rc > 0 or ! defined $json_ref) {
            print "Could not open the tool config file\n";
            exit 1;
        }
        if (! exists $$json_ref{'tool'} or $$json_ref{'tool'} ne $tool_name) {
            printf "In the following tool config, found in %s, the value for key \"tool\" ", $this_tool_config;
            printf "does not match the tool name, '%s'\n", $tool_name;
            printf "Either correct the tool config, or remove this tool from your test\n";
            my $coder = JSON::XS->new->canonical->pretty;
            printf "%s", $coder->encode($json_ref);
            exit 1;
        }
        $tools_configs{$$json_ref{'tool'}} = $json_ref;
    }
}

sub load_utility_params() {
    my $rc;
    foreach my $utility (@utilities) {
        if (exists $run{$utility . '-dir'}) {
            my $this_utility_config = $run{$utility . '-dir'} . "/rickshaw.json";
            ($rc, my $json_ref) = get_json_file($this_utility_config, $utility_schema_file);
            if ($rc > 0 or ! defined $json_ref) {
                print "Could not open the tool config file\n";
                exit 1;
            }
            if (! exists $$json_ref{'utility'} or $$json_ref{'utility'} ne $utility) {
                printf "In the following utility config, found in %s, the value for key \"utility\" ", $this_utility_config;
                printf "does not match the utility name, '%s'\n", $utility;
                printf "Please correct the utility config\n";
                my $coder = JSON::XS->new->canonical->pretty;
                printf "%s", $coder->encode($json_ref);
                exit 1;
            }
            $utility_configs{$$json_ref{'utility'}} = $json_ref;
        } else {
            printf "Could not determine utility location for '%s'\n", $utility;
            exit 1;
        }
    }
}

sub make_run_dirs() {
    # Ensure the bench-dir, base-run-dir, and tools-dir have absolute paths
    # because they may be referenced by clients and servers later
    for my $dirtype (qw(base-run-dir bench-dir tools-dir)) {
        {
            my $pushd_dir = pushd($run{$dirtype});
            debug_log(sprintf "pushd to [%s]\n", $run{$dirtype});
            my $cwd = getcwd();
            debug_log(sprintf "cwd [%s]\n", $cwd);
            $run{$dirtype} = $cwd;
        }
    }
    -e $run{'base-run-dir'} || mkdir($run{'base-run-dir'});
    debug_log(sprintf("Base run directory: [%s]\n", $run{'base-run-dir'}));
    debug_log(sprintf("Bench helper subproject directory: [%s]\n", $run{'bench-dir'}));
    $config_dir = $run{'base-run-dir'} . "/config";
    mkdir($config_dir);
    $client_server_config_dir = $config_dir . "/client-server";
    mkdir($client_server_config_dir);
    $client_server_bench_cmds_dir = $client_server_config_dir . "/bench-cmds";
    mkdir($client_server_bench_cmds_dir);
    $tool_cmds_dir = $config_dir . "/tool-cmds";
    mkdir($tool_cmds_dir);
    $run_dir = $run{'base-run-dir'} . "/run";
    mkdir($run_dir);
    $base_endpoint_run_dir = $run_dir . "/endpoint/";
    mkdir($base_endpoint_run_dir);
    $client_server_run_dir = $run_dir . "/client-server/";
    mkdir($client_server_run_dir);
    $client_server_logs_dir = $client_server_run_dir . "/logs/";
    mkdir($client_server_logs_dir);
    $client_server_archives_dir = $client_server_run_dir . "/archives/";
    mkdir($client_server_archives_dir);
    $client_server_run_script = $client_server_config_dir . "/client-server-script";
    $iterations_dir = $run_dir . "/iterations";
    mkdir($iterations_dir);
    $roadblock_msgs_dir = $run_dir . "/roadblock-msgs";
    mkdir($roadblock_msgs_dir);
    # If there are no endpoints, assume 1 endpoint using the 'local' extension
    if (scalar @endpoints == 0) {
        if (exists $bench_config{'client'} and exists $bench_config{'server'}) {
            add_endpoint(\@endpoints, "localhost", "client:1,server:1");
        } else {
            add_endpoint(\@endpoints, "localhost", "client:1");
        }
    }
}

sub validate_endpoints() {
    # Call each endpoint script with "--validate" as the first option, and each endpoint script should
    # return a list of clients and servers which are used from this endpoint.  Collect this output
    # and verify there are no gaps in the numbering of clients, and if the benchmark uses servers,
    # that there is 1 server for every client.
    # Why can't we just parse the endpoint option?  Because there is no gaurantee that the endpoint
    # option always contains the client and server IDs that will be used.  For example, an endpoint
    # for k8s might look like: "--endpoint:[1-5]" where client and server are not required, and when
    # not used, this endpoint assumes both clients and servers (for IDs 1-5) will be deployed. 
    # This ensures the format of the specific endpoint option string is completely up to that endpoint
    # and not rickshaw.
    my $min_id;
    my $max_id;
    printf "Confirming the endpoints will satisfy the benchmark-client ";
    printf "and benchmark-server " if exists $bench_config{'server'};
    printf "requirements\n";
    foreach my $endpoint (@endpoints) {
        my $pushd_dir = pushd($rickshaw_project_dir . "/endpoints/" . $$endpoint{'type'});
        my $cmd = "./" . $$endpoint{'type'} .
                " --endpoint-opts=" . $$endpoint{'opts'} .
                " --validate";
        debug_log(sprintf "endopoint validation command: [%s]\n", $cmd);
        ($cmd, my $output, my $cmd_rc) = run_cmd($cmd);
        my @output = grep(!/^#/, split(/\n/, $output));
        if ($cmd_rc > 0) {
            die "[ERROR]Endpoint " . $$endpoint{'type'} . " with options " . $$endpoint{'opts'} .
                " validation returned non-zero exit code:\n" . join("\n", @output) . "\n";
        }
        # Output from endpoint's validation should be 1 or more lines with "client" or "server"
        # followed by 1 or more positive integers representing the client/server IDs this
        # endpoint handles::
        # client <int> [int]
        # server <int> [int]
        foreach my $line (@output) {
            chomp $line;
            if ($line =~ /(client|server)\s+(.+)$/) {
                my $client_server = $1;
                my $ids = $2;
                foreach my $id (split(/\s+/, $ids)) {
                    die "[ERROR]client/server ID cannot be below 1\n" if ($id < 1);
                    my %info = ( 'endpoint-type' => $$endpoint{'type'}, 'id' => $id );
                    $clients_servers{$client_server}[$id - 1] = \%info;
                    push(@rb_cs_ids, $client_server . "-" . $id);
                    $min_id = $id if (! defined $min_id or $id < $min_id);
                    $max_id = $id if (! defined $max_id or $id > $max_id);
                }
            } elsif ($line =~ /(userenv)\s+(.+)$/) {
                $$endpoint{'userenv'} = $2;
                debug_log(sprintf("Clients/servers for endpoint %s will have userenv %s\n",
                    $$endpoint{'label'}, $$endpoint{'userenv'}));
                my %userenv_info = ( 'image' => '' );
                $userenvs{$$endpoint{'userenv'}} = \%userenv_info;
            } else {
                printf "[ERROR]output from endpoint validation incorrect:\n%s\n", $line;
                exit 1;
            }
        }
    }
    if ($min_id != 1) {
        printf "[ERROR]lowest ID found in clients and servers is %d, must be 1\n", $min_id;
        exit 1;
    }
    my $server_required = 0;
    if (exists $bench_config{'server'}) {
        debug_log("server is present\n");
        $server_required = 1;
        if (exists $bench_config{'server'}{'required'} && ! $bench_config{'server'}{'required'}) {
            debug_log("server is present but not required\n");
            $server_required = 0;
        } elsif (! exists $bench_config{'server'}{'required'}) {
            $bench_config{'server'}{'required'} = 1;
        }
    }
    my $servers_present = 0;
    my $clients_present = 0;
    for (my $id = $min_id; $id <= $max_id; $id++) {
        debug_log(sprintf "checking for client ID %d\n", $id);
        if (! defined $clients_servers{'client'}[$id - 1]) {
            printf "[ERROR]client ID %d is not defined in ID range %d - %d\n", $id, $min_id, $max_id;
            exit 1;
        } else {
            $clients_present++;
        }
        if (exists $bench_config{'server'}) {
            debug_log(sprintf "checking for server ID %d\n", $id);
            if (! defined $clients_servers{'server'}[$id - 1]) {
                if ($server_required) {
                    printf "[ERROR]server ID %d is not defined in ID range %d - %d\n",
                        $id, $min_id, $max_id;
                    exit 1;
                } else {
                    debug_log(sprintf "server ID %d missing but not required\n", $id);
                }
            } else {
                $servers_present++;
            }
        } else {
            debug_log(sprintf "checking for no server IDs\n");
            if (defined $clients_servers{'server'}[$id - 1]) {
                printf "[ERROR]server ID %d is defined in ID range %d - %d, but this benchmark " .
                    "does not use servers\n", $id, $min_id, $max_id;
                exit 1;
            }
        }
    }
    printf "There will be %d client(s)", $clients_present;
    printf " and %d server(s)", $servers_present if exists $bench_config{'server'} && $servers_present;
    printf "\n";
    if ($use_roadblock) {
        $endpoint_roadblock_opt = " --roadblock-id=" . $run{'id'} .
                                " --roadblock-passwd=" . $redis_passwd;
        $workshop_roadblock_opt = " --requirements " . $run{'roadblock-dir'} .
                                "/workshop.json ";
    } else {
        # If for some reason the user has opted to not use roadblock, then only allow
        # tests which use only one client and no server, which is the only possible
        # combination we can support without syncronization
        my $do_exit = 0;
        if (scalar @{ $clients_servers{'server'} } > 0) {
            printf "[ERROR}since --roadblock-dir was not used or the directory does not exist," .
                "rickshaw cannot run a test with servers because it cannot syncornize the test " .
                "without roadblock.\n";
                $do_exit = 1;
        }
        if (scalar @{ $clients_servers{'client'} } > 1) {
            printf "[ERROR}since --roadblock-dir was not used or the directory does not exist," .
                "rickshaw cannot run a test with multiple clients because it cannot synchronize " .
                "the test without roadblock.\n";
                $do_exit = 1;
        }
        if ($do_exit) {
            exit 1;
        }
    }
    $run{'endpoints'} = \@endpoints;
}

sub build_test_order() {
    printf "Building test execution order\n";
    # Build test execution order (and the iteration/sample dirs)
    if ($run{'test-order'} eq 's') {
        for (my $iid = 1; $iid <= scalar @{ $run{'iterations'} }; $iid++) {
            for (my $sid = 1; $sid <= $run{'num-samples'}; $sid++) {
                my %test = ('iteration-id' => $iid, 'sample-id' => $sid);
                push(@tests, \%test);
            }
        }
    } elsif ($run{'test-order'} eq 'i') {
        for (my $sid = 1; $sid <= $run{'num-samples'}; $sid++) {
            for (my $iid = 1; $iid <= scalar @{ $run{'iterations'} }; $iid++) {
                my %test = ('iteration-id' => $iid, 'sample-id' => $sid);
                push(@tests, \%test);
            }
        }
    } elsif ($run{'test-order'} eq 'r') {
        my $total_samples = scalar( @{$run{'iterations'} }) * $run{'num-samples'};
        my @available_tests;
        for (my $iid = 1; $iid <= scalar @{ $run{'iterations'} }; $iid++) {
            my %test = ('iteration-id' => $iid);
            $test{'samples'} = [];
            for (my $sid = 1; $sid <= $run{'num-samples'}; $sid++) {
                push(@{ $test{'samples'} }, $sid);
            }
            push(@available_tests, \%test);
        }
        while(scalar(@available_tests)) {
            my $random_iteration = int(rand(scalar(@available_tests)));
            my %test = ('iteration-id' => $available_tests[$random_iteration]{'iteration-id'},
                        'sample-id' => shift( @{ $available_tests[$random_iteration]{'samples'} } ));
            push(@tests, \%test);
            if (scalar( @{ $available_tests[$random_iteration]{'samples'} } ) == 0) {
                splice @available_tests, $random_iteration, 1;
            }
        }
        if (scalar(@tests) != $total_samples) {
            printf "[ERROR]Expected %d tests but found %d --> is the random test-order algorithm broken?\n", $total_samples, scalar(@tests);
            exit 1;
        }
    } else {
        printf "[ERROR]Value for --test-order [%s] is not valid\n", $run{'test-order'};
        usage;
        exit 1;
    }
    if (put_json_file($config_dir . "/test-order.json", \@tests) > 0) {
        printf "build_test_order(): put_json_file() failed for %s\n", $config_dir . "/test-order.json";
    }
}

sub prepare_bench_tool_engines() {
    # Run on the controller (the host running this script) the benchmark-specific "pre-script"
    if (exists $bench_config{"controller"}{"pre-script"} and $bench_config{"controller"}{"pre-script"} ne "") {
        my $pushd_dir = pushd($run_dir);
        # Note that the user params for the benchmark are from the first set only
        # This pre-script is run only once before all of the tests are started.
        # If this script generates a file to aid in benchmark execution (such as a job file),
        # The file should work for all perams sets (all benchmark iterations).  If you need
        # different job files per iteration, then use the client or server-side "pre-script"
        # to either augment a file generated here or create a completely new file.
        my $cmd = $bench_config{"controller"}{"pre-script"} . " " . dump_params($run{'iterations'}[0]{'params'});
        $cmd =~ s/\%bench-dir\%/$run{'bench-dir'}/g;
        $cmd =~ s/\%run-dir\%/$run_dir/g;
        debug_log(sprintf "controller pre-script command: [%s]\n", $cmd);
        ($cmd, my $pre_cmd_output, my $cmd_rc) = run_cmd($cmd);
        if ($cmd_rc != 0) {
            printf "controller pre-script failed with return code = %d\n", $cmd_rc;
            printf "controller pre-script command: %s\n", $cmd;
            printf "controller pre-script output:\n%s", join("\n", $pre_cmd_output);
            exit $cmd_rc;
        }
        debug_log(sprintf "controller pre-script output:\n%s", join("\n", $pre_cmd_output));
    }
    copy($run{'engine-dir'} . "/client-server-script", $client_server_run_script)
        || die "Could not copy client-server-script to " . $client_server_run_script .
            "/client-server-script";
    chmod 0755, "$client_server_run_script";
    # Each tool may specify, for specific endpoints, that it needs to run somewhere other than a client
    # or server (a "collector").  This preference is in the "whitelist" section.  Check each tool used
    # to see if we need to build a command file for any of these collectors.
    my %collectors;
    foreach my $tool_entry (@tools_params) {
        my $tool_name = $$tool_entry{'tool'};
        if (exists $tools_configs{$tool_name}{'collector'}{'whitelist'}) {
            for my $i (@{ $tools_configs{$tool_name}{'collector'}{'whitelist'} }) {
                my $endpoint = $$i{'endpoint'};
                # Does this endpoint in tool config match one of th endpoints used for this run?
                if (grep(/^$endpoint$/, dump_endpoint_types(\@endpoints))) {
                    # Then add this tool to the list of tools for this collector
                    for my $collector (@{ $$i{'collector-types'} }) {
                        if (! exists($collectors{$collector})) {
                            $collectors{$collector} = ();
                        }
                        push(@{ $collectors{$collector} }, $tool_name);
                    }
                }
            }
        }
    }
    # Now build all of the tool start and stop cmd files for each collector
    for my $collector (keys %collectors) {
        for my $start_stop ("start", "stop") {
            my $collector_tool_cmds_dir = $tool_cmds_dir . "/" . $collector;
            -e $collector_tool_cmds_dir || make_path($collector_tool_cmds_dir) ||
                die "[ERROR]Create collector directory failed: [" . $collector_tool_cmds_dir . "]\n";
            my $tool_cmd_file = $collector_tool_cmds_dir . "/" . $start_stop; 
            open(my $fh, ">" . $tool_cmd_file) ||
                die "[ERROR]could not open cmd file for writing: [" . $tool_cmd_file . "]\n";
            debug_log(sprintf "writing tool-cmds [%s]\n", $tool_cmd_file);
            foreach my $tool_entry (@tools_params) {
                my $tool_name = $$tool_entry{'tool'};
                if (grep($tool_name, @{ $collectors{$collector} })) {
                    my $tool_cmd = $tool_name . ": " . $tools_configs{$tool_name}{'collector'}{$start_stop};
                    foreach my $tool_param (@{ $$tool_entry{'params'} }) {
                        $tool_cmd .= " --" . $$tool_param{'arg'} . " " . $$tool_param{'val'};
                    }
                    printf $fh "%s\n", $tool_cmd;
                }
            }
            close($fh);
            chmod 0755, $tool_cmd_file;
        }
    }
    # By default all tools run on client and servers.  However,
    # in some cases tools should not be run in the client or server, either
    # because there is nothing to collect in that runtime, or the tool is
    # already collecting that data from a different source (and a client
    # and/or server would be collecting duplicate data).  For this reason tool
    # cmd files are built specifically for each client and server.
    foreach my $cs_type (keys %clients_servers) {
        for my $start_stop ("start", "stop") {
            foreach my $cs_ref (@{ $clients_servers{$cs_type} }) {
                my $cs_tool_cmds_dir = $tool_cmds_dir . "/" . $cs_type . "/" . $$cs_ref{'id'};
                make_path($cs_tool_cmds_dir);
                my $tool_cmd_file = $cs_tool_cmds_dir . "/" . $start_stop;
                open(TOOL_CMD_FH, ">" . $tool_cmd_file) ||
                    die "[ERROR]could not open cmd file for writing: [" . $tool_cmd_file . "]\n";
                my $cs_endpoint = $$cs_ref{'endpoint-type'};
                foreach my $tool_entry (@tools_params) {
                    my $tool_name = $$tool_entry{'tool'};
                    my $tool_cmd = $tool_name . ": " . $tools_configs{$tool_name}{'collector'}{$start_stop};
                    foreach my $tool_param (@{ $$tool_entry{'params'} }) {
                        $tool_cmd .= " --" . $$tool_param{'arg'} . " " . $$tool_param{'val'};
                    }
                    # Check if the client/server is deployed by an endpoint that blacklists this tool 
                    if (exists $tools_configs{$tool_name}{'collector'}{'blacklist'}) {
                        for my $i (@{ $tools_configs{$tool_name}{'collector'}{'blacklist'} }) {
                            if ($$cs_ref{'endpoint-type'} eq $$i{'endpoint'}) {
                                # If it is, don't let this client/server run this tool
                                debug_log(sprintf "%s %d will not run tool %s\n",
                                                $cs_type, $$cs_ref{'id'}, $tool_name);
                                undef $tool_cmd;
                            }
                        }
                    }
                    if (defined $tool_cmd) {
                        printf TOOL_CMD_FH "%s\n", $tool_cmd;
                    }
                }
                close(TOOL_CMD_FH);
            }
        }
    }
    # Build the client and server bench-cmd files
    # Each benchmark has to define the commands used in their rickshaw.json
    foreach my $cs_type (keys %clients_servers) {
        foreach my $cs_ref (@{ $clients_servers{$cs_type} }) {
            my @cmd_type_files = ("start");
            if ($cs_type eq "server") {
                push(@cmd_type_files, "stop");
            }
            if ($cs_type eq "client") {
                push(@cmd_type_files, "runtime");
            }
            if ($cs_type eq "client") {
                push(@cmd_type_files, "infra");
            }
            my $cs_id = $$cs_ref{'id'};
            my $this_cmds_dir = $client_server_bench_cmds_dir . "/" . $cs_type . "/" . $cs_id;
            make_path($this_cmds_dir) || die "Could not mkdir " . $this_cmds_dir;
            foreach my $cmd_type (@cmd_type_files) {
                next if ($cmd_type eq "runtime" and $cs_id > 1); # runtime cmds only for client-1
                my $this_cmd_file = $this_cmds_dir . "/" . $cmd_type;
                open(FH, ">" . $this_cmd_file) ||
                    die "[ERROR]Open bench-cmds file for writing failed: [" . $this_cmd_file . "]\n";
                debug_log(sprintf "writing bench-cmds [%s]\n", $this_cmd_file);
                foreach my $test_ref (@tests) {
                    my $test_iter = $$test_ref{'iteration-id'};
                    my $test_samp = $$test_ref{'sample-id'};
                    my $iter_array_idx = $test_iter - 1;
                    if (exists $bench_config{$cs_type}{$cmd_type} and
                        $bench_config{$cs_type}{$cmd_type} ne "") {
                        my $cmd = $bench_config{$cs_type}{$cmd_type} . " " .
                                dump_params($run{'iterations'}[$iter_array_idx]{'params'}, $cs_id, $cs_type);
                        debug_log(sprintf "cmd: [%s]\n", $cmd);
                        # Apply a regex from the benchmark config file to the command
                        # This is used to remove things like "--clients=" because the
                        # native benchmark does not understand this parameter
                        if ($bench_config{$cs_type} and $bench_config{$cs_type}{"param_regex"}) {
                            for my $r (@{ $bench_config{$cs_type}{"param_regex"} }) {
                                # to apply the 's/x/y/' regex from the file, some eval trickery is necessary
                                # todo: first test the $r regex separately for [perl syntax] errors with eval
                                # before doing below
                                $cmd = eval "\$_='$cmd'; $r; return scalar \$_";
                            }
                        }
                        printf FH "%d-%d %s\n", $test_iter, $test_samp, $cmd;
                    } else {
                        # infra command is optional
                        if ($cmd_type ne "infra") {
                            die "[ERROR]Could not find " . $cmd_type . " in bench_config\n";
                        }
                    }
                }
                close FH;
                chmod 0755, $this_cmd_file;
            }
        }
    }
    # Build the client/server "from-controller" files list and put them in the base endpoint run dir.
    # These are files the client/server must copy from the controller before running any tests.
    # The "client-server-script" will first scp the list (client-files-list or server-files-list).
    # then it will read this list to know what other files to copy over)
    #
    # TODO: build these files for other collectors
    foreach my $cs_type (keys %clients_servers, keys %collectors) {
        my $cs_file_list = $client_server_config_dir . "/" . $cs_type . "-files-list";
        open(FH, ">" . $cs_file_list) || die "[ERROR]could not open " . $cs_file_list . " for writing";
        if ($cs_type =~ /(client|server)/ and exists $bench_config{$cs_type}{"files-from-controller"}) {
            for my $file_spec (@{ $bench_config{$cs_type}{"files-from-controller"} } ) {
                my $src_file = $$file_spec{'src'};
                $src_file =~ s/\%bench-dir\%/$run{'bench-dir'}\//g;
                $src_file =~ s/\%run-dir\%/$run_dir\//g;
                $src_file =~ s/\%config-dir\%/$config_dir\//g;
                my $dest_file = $$file_spec{'dest'};
                printf FH "src=%s\ndest=%s\n", $src_file, $dest_file;
            }
        }
        foreach my $tool_entry (@tools_params) {
            my $tool_name = $$tool_entry{'tool'};
            if (exists $tools_configs{$tool_name}{'collector'}{'files-from-controller'}) {
                for my $file_spec (@{ $tools_configs{$tool_name}{'collector'}{"files-from-controller"} } ) {
                    my $src_file = $$file_spec{'src'};
                    $src_file =~ s/\%tool-dir\%/$run{'tools-dir'}\/$$tool_entry{'tool'}\//g;
                    $src_file =~ s/\%run-dir\%/$run_dir\//g;
                    $src_file =~ s/\%config-dir\%/$config_dir\//g;
                    my $dest_file = $$file_spec{'dest'};
                    printf FH "src=%s\ndest=%s\n", $src_file, $dest_file;
                }
            }
        }
        foreach my $utility (@utilities) {
            my $utility_dir = $run{$utility . '-dir'};
            if (exists $utility_configs{$utility}{'engine'}{'files-from-controller'}) {
                for my $file_spec (@{ $utility_configs{$utility}{'engine'}{'files-from-controller'} }) {
                    my $src_file = $$file_spec{'src'};
                    $src_file =~ s/\%utility-dir\%/$utility_dir/g;
                    my $dest_file = $$file_spec{'dest'};
                    printf FH "src=%s\ndest=%s\n", $src_file, $dest_file;
                }
            }
        }
        close FH;
    }
}

sub add_ssh_keys() {
    # Create temporary ssh keys so endpoint clients/servers can pull/push data
    my $keygen_cmd = 'ssh-keygen -f ' . $config_dir . '/rickshaw_id.rsa -P "" 2>&1';
    ($keygen_cmd, my $keygen_output, my $keygen_cmd_rc) = run_cmd($keygen_cmd);
    system('cat ' . $config_dir . '/rickshaw_id.rsa.pub >>/root/.ssh/authorized_keys');
}

sub deploy_endpoints() {
    # Deploy ths endpoints so they are ready to run benchmark and tools.
    # Each endpoint is responible for launching a osruntime for each client and server.
    print "Deploying endpoints\n";
    debug_log(sprintf "\nendpoint output:\n");
    for (my $i = 0; $i < scalar @endpoints; $i++) {
        my $type = $endpoints[$i]{'type'};
        my $opts = $endpoints[$i]{'opts'};
        my $label = $endpoints[$i]{'label'};
        my $userenv = $endpoints[$i]{'userenv'};
        my $endpoint_image_opt = "";
        if (defined $endpoints[$i]{'userenv'}) {
            $endpoint_image_opt = " --image=$userenvs{$endpoints[$i]{'userenv'}}{'image'}";
        }
        my $this_endpoint_run_dir = $base_endpoint_run_dir . "/" . $label;
        mkdir($this_endpoint_run_dir);
        die "Could not create $this_endpoint_run_dir" if ! -e $this_endpoint_run_dir;
        my $endpoint_project_dir = $rickshaw_project_dir . "/endpoints/" . $type;
        if (-e $endpoint_project_dir) {
            my $pushd_dir = pushd($endpoint_project_dir);
            my $cmd = "./" . $type .
                    " --endpoint-opts=" . $opts .
                    " --endpoint-label=" . $label .
                    " --run-id=" . $run{'id'} .
                    " --base-run-dir=" . $run{'base-run-dir'} .
                    " --max-sample-failures=" . $run{'max-sample-failures'} .
                    " --max-rb-attempts=" . $run{'max-rb-attempts'} .
                    $endpoint_image_opt .
                    $endpoint_roadblock_opt .
                    " >" . $this_endpoint_run_dir . "/endpoint-stdout.txt" .
                    " 2>" . $this_endpoint_run_dir . "/endpoint-stderr.txt";
            # The below 'system' needs to be forked, then wait for all to finish.
            # The endpoint program should get all clients/servers "ready", that is,
            # waiting for instructions from roadblock.  The above command needs
            # info about how to contact roadblock.
            # Endpoints should return for each client and server started:
            # - the ID of the client/server
            # - the roadblock client ID
            debug_log(sprintf "Going to run endpoint command:\n%s\n\n", $cmd);
            if ($endpoint_roadblock_opt eq "") {
                # There is only one client and no synchronization, so we wait for the endpoint to finish
                debug_log(sprintf "going to run and wait for: %s\n", $cmd);
                #system($cmd);
            } else {
                #debug_log(sprintf "going to run %s\n", $cmd);
                system($cmd . " &");
            }
        } else {
            printf "[ERROR]could not find endpoint ./endpoints/%s\n", $type;
            exit 1;
        }
    }
}

sub process_roadblocks() {
    # Work progresses in the following way: pre-test-setup, tests, post-tests-cleanup
    # The number of actions taken in post-tests-cleanup depends on how far pre-test-setup
    # progressed.  If at any point the pre-test-setup aborts, it is important to 
    # cleanup properly.  All roadblock particpants need the same conditional approach.
    # First confirm endpoints are deployed (all osruntimes have launched client-server-script)
    my @new_followers;
    if (roadblock_leader("endpoint-deploy", $endpoint_deploy_timeout, $messages_ref, dump_endpoint_labels(\@endpoints)) == 0) {
        # Endpoints may introduce new followers for remaining roadblocks.  These followers are typically osruntimes which
        # are only running tools.
        if (defined $messages_ref) {
            foreach my $msg (@{ $$messages_ref{'received'} })  {
                if (exists $$msg{'payload'}{'message'}{'user-object'}{'new-followers'}) {
                    @new_followers = @{ $$msg{'payload'}{'message'}{'user-object'}{'new-followers'} };
                    printf "Endpoint created followers: %s\n", join(" ", sort(@new_followers));
                    @rb_cs_ids = (@rb_cs_ids, @new_followers);
                }
            }
        }
        # Next step all client-servers through pre-test preparation
        if (roadblock_leader("client-server-script-start", $client_server_script_timeout, $messages_ref, (@rb_cs_ids, dump_endpoint_labels(\@endpoints))) == 0) {
            if (roadblock_leader("client-server-get-data", $client_server_script_timeout, $messages_ref, (@rb_cs_ids, dump_endpoint_labels(\@endpoints))) == 0) {
                if (roadblock_leader("client-server-collect-sysinfo", $client_server_script_timeout, $messages_ref, (@rb_cs_ids, dump_endpoint_labels(\@endpoints))) == 0) {
                    if (roadblock_leader("client-server-start-tools", $default_rb_timeout, $messages_ref, (@rb_cs_ids, dump_endpoint_labels(\@endpoints))) == 0) {
                        if (roadblock_leader("client-server-start-tests", $default_rb_timeout, $messages_ref, (@rb_cs_ids, dump_endpoint_labels(\@endpoints))) == 0) {
                            # Now cycle through all tests
                            printf "Running tests:\n";
                            run_tests;
                        }
                        # Finally step through shutdown, cleanup, and sending data back
                        roadblock_leader("client-server-stop-tests", $default_rb_timeout, $messages_ref, (@rb_cs_ids, dump_endpoint_labels(\@endpoints)));
                        roadblock_leader("client-server-stop-tools", $default_rb_timeout, $messages_ref, (@rb_cs_ids, dump_endpoint_labels(\@endpoints)));
                    }
                    roadblock_leader("client-server-send-data", $default_rb_timeout, $messages_ref, (@rb_cs_ids, dump_endpoint_labels(\@endpoints)));
                }
            }
            roadblock_leader("client-server-script-stop", $default_rb_timeout, $messages_ref, (@rb_cs_ids, dump_endpoint_labels(\@endpoints)));
        }
        # Endpoints can now "un"-deploy, removing osruntimes
        roadblock_leader("endpoint-move-data", $endpoint_move_data_rb_timeout, $messages_ref, dump_endpoint_labels(\@endpoints));
    }
    roadblock_leader("endpoint-finish", $default_rb_timeout, $messages_ref, dump_endpoint_labels(\@endpoints));
}

sub organize_run_data() {
    debug_log("Moving per-client/server/tool data into common iterations and tool-data directories\n");
    # Organize the data from the clients/servers into a common directory structure, organized by
    # iteration, then by sample, then finally by client/server.  This is needed to have
    # the benchmark's postprocessing script work.
    #
    # Tool data is not organized by iteration/sample because it is collected continuously.
    my $pp_cmd = $bench_config{'controller'}{'post-script'};
    $pp_cmd =~ s/\%bench-dir\%/$run{'bench-dir'}\//g;
    $pp_cmd =~ s/\%run-dir\%/$run_dir\//g;
    $pp_cmd =~ s/\%config-dir\%/$config_dir\//g;
    my $tmp_data_dir = $run_dir . "/tmp-data-dir";
    {
        mkdir($tmp_data_dir);
        my $pushd_dir = pushd($tmp_data_dir);
        foreach my $archive (dir_entries($client_server_archives_dir,
                                        qr/^(\w+)-(\d+)-data\.tgz$/)) {
            $archive =~ /^(\w+)-(\d+)-data\.tgz$/ or next;
            my $archive_full_path = $client_server_archives_dir . "/" . $archive;
            my $cs_type = $1;
            my $cs_id = $2;
            my $tar_cmd = "tar zmxf " . $archive_full_path;
            ($tar_cmd, my $tar_output, my $tar_cmd_rc) = run_cmd($tar_cmd);
            if ($1 =~ /^(client|server)$/) {
                for (my $i = 1; $i <= scalar @{ $run{'iterations'} }; $i++) {
                    my $iter_dir = "iteration-" . $i;
                    if (-d $iter_dir) {
                        opendir(DH, $iter_dir);
                        my @entries =  readdir(DH);
                        foreach my $samp_dir (grep(/^sample/, @entries)) {
                            my $iter_sampl_subpath = $iter_dir . "/" . $samp_dir;
                            my $cs_dest_sampl_path = $run_dir . "/iterations/" . $iter_sampl_subpath .
                                        "/" . $cs_type . "/" . $cs_id;
                            make_path($cs_dest_sampl_path);
                            if (-e $iter_sampl_subpath) {
                                my $iter_sampl_dir = pushd($iter_sampl_subpath);
                                my $mv_cmd = "/bin/mv * " . $cs_dest_sampl_path;
                                ($mv_cmd, my $mv_output, my $mv_cmd_rc) = run_cmd($mv_cmd);
                            }
                        }
                    }
                }
            }
            if (scalar dir_entries("tool-data", qr/\w+/) > 0) {
                my $tool_dir = pushd("tool-data");
                my $cs_tool_dest_path = $run_dir . "/tool-data/" . $cs_type . "/" . $cs_id;
                make_path($cs_tool_dest_path);
                my $mv_cmd = "/bin/mv * " . $cs_tool_dest_path;
                ($mv_cmd, my $mv_output, my $mv_cmd_rc) = run_cmd($mv_cmd);
            }
            if (scalar dir_entries("sysinfo", qr/\w+/) > 0) {
                my $sysinfo_dir = pushd("sysinfo");
                my $cs_sysinfo_dest_path = $run_dir . "/sysinfo/" . $cs_type . "/" . $cs_id;
                make_path($cs_sysinfo_dest_path);
                my $mv_cmd = "/bin/mv * " . $cs_sysinfo_dest_path;
                ($mv_cmd, my $mv_output, my $mv_cmd_rc) = run_cmd($mv_cmd);
            }
            # Must be cleaned up in every loop iteraiton
            system("/bin/rm -rf " . $tmp_data_dir . "/*");
            if ($toolbox::logging::debug == 0) {
                system("/bin/rm -rf " .  $archive_full_path);
            }
        }
    }
    rmdir($tmp_data_dir);
}



process_cmdline();
validate_controller_env();
load_bench_params();
load_tool_params();
load_utility_params();
make_run_dirs();
validate_endpoints();
build_test_order();
prepare_bench_tool_engines();
foreach my $userenv (keys %userenvs) {
    $userenvs{$userenv}{'image'} = build_container_image($userenv);
}
add_ssh_keys();
deploy_endpoints();
process_roadblocks();
organize_run_data();
# TODO: remove temporary ssh keys from local authorized_keys file
my $run_file = $run_dir . "/rickshaw-run.json";
$run{'rickshaw-run'}{'schema'}{'version'} = "2020.03.18";
if (put_json_file($run_file, \%run, $run_schema_file) > 0) {
    printf "main(): put_json_file() failed for %s\n", $run_file
}
if (defined $abort_test_id) {
    printf "WARNING: test %s was aborted. and all subsequent tests were not attempted.  " .
           "Run is incomplete\n", $abort_test_id;
    exit 1;
}
